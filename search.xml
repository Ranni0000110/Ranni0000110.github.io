<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于Redis的一些进阶问题</title>
      <link href="/2024/09/25/2024-9-25-%E5%85%B3%E4%BA%8ERedis%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2024/09/25/2024-9-25-%E5%85%B3%E4%BA%8ERedis%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Redis的持久化"><a href="#关于Redis的持久化" class="headerlink" title="关于Redis的持久化"></a>关于Redis的持久化</h1><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB(Redis DataBase Backup file),也叫Redis数据快照。主要工作方法是在一定时间间隔内将Redis在某一时刻的数据保存到磁盘中的RDB文件中。<br>主要有两条命令触发RDB:</p><ul><li>save：手动触发RDB持久化。由于Redis是单线程，所以使用<strong>save</strong>命令时会造成所有请求的阻塞，直到<strong>save</strong>命令执行完后才可以执行其他请求。</li><li>bgsave：后台异步执行RDB持久化，不会阻塞主进程。<strong>推荐</strong><h3 id="自动触发RDB"><a href="#自动触发RDB" class="headerlink" title="自动触发RDB"></a>自动触发RDB</h3>在 Redis 配置文件（通常是 redis.conf）中，可以通过save &lt; seconds &gt; &lt; changes &gt;指令配置自动触发 RDB 持久化的条件。这个指令可以设置多次，每个设置定义了一个时间间隔（秒）和该时间内发生的变更次数阈值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 (有1个键被修改，900秒后自动触发一次RDF)</span><br><span class="line">save 300 10 (有10个键被修改，300秒后自动触发一次RDF)</span><br><span class="line">save 60 10000 (有10000个键被修改，60秒后自动触发一次RDF)</span><br></pre></td></tr></table></figure><h3 id="关于“bgsave”的流程（fork）"><a href="#关于“bgsave”的流程（fork）" class="headerlink" title="关于“bgsave”的流程（fork）"></a>关于“bgsave”的流程（fork）</h3>在运行<strong>bgsave</strong>命令时会通过<strong>fork()</strong>系统调用创建子进程，子进程共享主进程的内存数据。读取内存数据并写入RDB文件。<br>主进程不直接操作物理内存，而是将内存快照写入虚拟内存中。操作系统会维护一张虚拟内存和物理内存的映射关系表，叫做页表。主进程基于页表的映射关系对物理内存进行读写。<br>执行<strong>fork()</strong>时，主进程把页表拷贝给子进程，这样我们就无需拷贝内存数据但是可以操作物理内存，效率很高。<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4>当我们的主进程在写入数据而同时子进程在读出数据时，会发生老生常谈的线程安全问题，可能会读到脏数据。<br>而伟大的Redis早已想到了这一切。<br><strong>fork</strong>采用的是copy-on-write机制，即当主进程执行读操作时，主进程和子进程可以访问共享内存一起读。在主进程执行写操作时，共享内存会被设置成只读模式，同时复制一份拷贝的副本用来执行主线程的写操作。从此以后主线程的页表映射关系就转换为了复制的副本。<br><strong>注意</strong> 因为cow机制给主进程准备了一份副本随便修改，而子进程读取的仍然是原来的共享内存，所以主进程和子进程在修改后的数据是不一致的。子进程是一次性的进程，子进程在完成了RDB的写入后会通知父进程，父进程使用新的RDB文件替换原来的文件。<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3>RDB生成快照对Redis性能影响小<br>RDB文件紧凑，适合传输、备份<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3>RDB执行间隔长，两次RDB间写入数据有丢失风险<br>fork子进程、压缩、写出RDB文件都较为耗时</li></ul><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF是通过记录每个写操作的命令并将其追加到AOF文件中，恢复时重新执行这些命令来重建数据，以保证持久化。<br>AOF持久化需要配置是否开启，默认关闭。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><br>AOF提供了三种方案以保证持久化，分别是：</p><ul><li>always：每执行一条命令都同步追加到AOF文件，保证数据完整性。（可靠性高，但是性能较差）</li><li>everysec：每秒钟同步一次AOF文件，保证数据完整性。<strong>推荐</strong>（性能适中，最多损失1s的数据）</li><li>no：关闭AOF持久化。（性能高，但是可靠性为0）<h3 id="BGREWRITEAOF机制"><a href="#BGREWRITEAOF机制" class="headerlink" title="BGREWRITEAOF机制"></a>BGREWRITEAOF机制</h3>由于AOF持久化的应对方案是把所有数据操作命令都写入AOF文件中，这就会导致如果我们<strong>set num 123</strong>,之后我们又<strong>set num 456</strong> ,这两个命令都会记录在AOF文件中，这就造成了AOF文件过大，并且恢复时需要执行大量的命令。<br>为了解决这个问题，Redis提供了<strong>BGREWRITEAOF</strong>命令，它会创建一个新的AOF文件，重写原有的AOF文件，用最少的命令达到相同的效果。<br>但就算AOF使用了该命令，AOF文件还是会比RDB生成的文件要大，因为AOF记录的是所有命令，但是RDB记录的只是数据。<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3>灵活，实时性强，每次写入命令就同步。在频繁写入条件下，AOF比RDB更可靠。<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3>AOF文件过大，性能影响大，恢复速度慢。</li></ul><h2 id="Redis的数据恢复流程"><a href="#Redis的数据恢复流程" class="headerlink" title="Redis的数据恢复流程"></a>Redis的数据恢复流程</h2><p>Redis在进行数据恢复时会优先判断<strong>AOF</strong>是否开启且文件是否存在，若存在则优先使用<strong>AOF</strong>来进行数据恢复。若AOF关闭或AOF文件不存在Redis才会使用<strong>RDB</strong>进行数据恢复。</p><h1 id="关于Redis的主从机制"><a href="#关于Redis的主从机制" class="headerlink" title="关于Redis的主从机制"></a>关于Redis的主从机制</h1><h2 id="主从复制-读写分离"><a href="#主从复制-读写分离" class="headerlink" title="主从复制 读写分离"></a>主从复制 读写分离</h2><p>Redis的主从复制是实现Redis高可用和数据分片的一种方式。<br>主从复制的原理是：一个主Redis服务器负责处理所有的写操作，并将数据同步到从Redis服务器。从Redis服务器可以进行读操作，但数据来自主Redis服务器。这样就保证了Redis的读写分离，保证高可用。</p><h3 id="主从复制数据同步原理（全量同步）"><a href="#主从复制数据同步原理（全量同步）" class="headerlink" title="主从复制数据同步原理（全量同步）"></a>主从复制数据同步原理（全量同步）</h3><p>第一次主从复制是<strong>全量同步</strong>：</p><ul><li>从服务器请求数据同步,携带Replid和偏移量</li><li>主服务器通过replid判断从服务器是不是第一次同步</li><li>是第一次，主服务器返回master的replid和offset</li><li><p>从服务器保存版本信息</p></li><li><p>主服务器执行bgsave命令生成RDB文件,同时记录RDB期间的所有命令到repl_backlog文件中</p></li><li>主服务器将RDB文件发送给从服务器</li><li>从服务器接收RDB文件并写入到磁盘</li><li><p>从服务器清空旧数据，加载RDB文件</p></li><li><p>主服务器发送repl_backlog文件中的命令</p></li><li>从服务器执行命令，将数据同步到从服务器<h4 id="master判断slave是否是第一次同步"><a href="#master判断slave是否是第一次同步" class="headerlink" title="master判断slave是否是第一次同步"></a>master判断slave是否是第一次同步</h4></li><li>Replication id:master的唯一标识，slave会在第一次同步时继承masters的Replication id,并在之后的同步中保持相同的Replication id。当master和slave的Replication id相同时，就可以判断不是第一次同步，所以不使用全量同步。</li><li>Offset:master的当前偏移量，slave会在第一次同步时继承masters的偏移量，并在之后的同步中保持相同的偏移量。若slave的偏移量小于master的偏移量，则说明master的数据有更新，slave需要进行同步。</li><li>第一次同步时，master会记录当前的Replication id和偏移量，并发送给slave。</li></ul><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><ul><li>从服务器请求数据同步，携带replid和偏移量</li><li>主服务器根据replid判断是否第一次同步</li><li><p>不是第一次，返回continue</p></li><li><p>主服务器从repl_backlog中读取偏移量之后的数据，并返回给从服务器</p></li><li>从服务器执行命令，将数据同步到从服务器</li></ul><p><strong>注意</strong><br>repl_backlog文件有上限，当大小超过上限就会覆盖之前的数据。如果slave断开的太久，导致尚未备份的数据被覆盖，则slave只能再次进行全量同步。</p><h2 id="集群优化"><a href="#集群优化" class="headerlink" title="集群优化"></a>集群优化</h2><ul><li>在master中配置repl-diskless-sync yes,启动无磁盘复制，减少磁盘IO。此方法适用于磁盘读写能力差但网络带宽高的场景。</li><li>Redis单节点内存占用不要过大，减少RDB导致的过多IO。</li><li>适当提高repl_backlog文件大小，发现slave宕机尽快恢复，尽量避免全量同步。</li><li>限制master上的slave数量，slave数量太多情况下可以采用主-从-链式结构，减轻master的压力。</li></ul><h1 id="哨兵机制（Sentinel）"><a href="#哨兵机制（Sentinel）" class="headerlink" title="哨兵机制（Sentinel）"></a>哨兵机制（Sentinel）</h1><p>用于监控Redis的主从复制，自动完成故障转移并通知管理员。</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>Sentinel会不断检查master和slave是否按期工作。</p><h3 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群中的每个实例发送ping命令。</p><ul><li>主观下线：某Sentinel节点发现某实例未在一定时间内响应，则认为该实例主观下线。</li><li>客观下线：若超过指定数量的Sentinel节点都认为某实例主观下线，则认为该实例客观下线。指定数量需超过Sentinel节点数的一半。<h2 id="自动故障恢复"><a href="#自动故障恢复" class="headerlink" title="自动故障恢复"></a>自动故障恢复</h2>当master出现故障时，Sentinel会自动选举一个slave作为新的master。故障恢复后也会以心跳的master为主。<h3 id="选举依据"><a href="#选举依据" class="headerlink" title="选举依据"></a>选举依据</h3></li><li>判断slave节点与master节点之间的断开时间长短，时间超出指定值（down-after-milliseconds * 10）的slave节点会被排除。</li><li>判断slave节点的slave-priority值，越小优先级越高，但是0不会被选举。</li><li>若slave-priority相同，则选择偏移量较大的slave，偏移量越大代表数据越新。</li><li>判断slave节点的运行id大小，越小优先级越高。<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2>Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息通知给客户端。<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3></li><li>Sentinel给备选的slave节点发送 <strong>slaveof no one</strong>命令，让该节点成为master。</li><li>Sentinel给所有其他slave节点发送 <strong>slaveof ip port</strong>命令，让它们成为新master的从节点。</li><li>Sentinel将故障节点标记为slave,故障节点恢复后会自动成为新master节点的从节点。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于在Linux系统中部署Redis</title>
      <link href="/2024/09/22/2024-9-22-%E5%85%B3%E4%BA%8E%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%83%A8%E7%BD%B2Redis/"/>
      <url>/2024/09/22/2024-9-22-%E5%85%B3%E4%BA%8E%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%83%A8%E7%BD%B2Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装gcc环境"><a href="#安装gcc环境" class="headerlink" title="安装gcc环境"></a>安装gcc环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc</span><br></pre></td></tr></table></figure><p>若yum出现<strong>Cannot find a valid baseurl for repo: base/7/x86_64</strong>，那么很不幸，你和我出了一样的问题<br>具体解决办法可以查看下面的博客：<br><a href="https://blog.csdn.net/weixin_46059351/article/details/140649426">https://blog.csdn.net/weixin_46059351/article/details/140649426</a><br>总结下来一般是DNS出了问题，首先需要修改<strong>/etc/sysconfig/network-scripts/ifcfg-ens33</strong>文件，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">BOOTPROTO=“static” (修改)</span><br><span class="line">...</span><br><span class="line">(输入ip addr查询自己的ip然后填入)</span><br><span class="line">IPADDR=“xx.xx.xx.xx”</span><br><span class="line">GATEWAY=xx.xx.xx.1”</span><br><span class="line">DNS1=“8.8.8.8”</span><br><span class="line">DNS2=“8.8.4.4”</span><br><span class="line">NETMASK=“255.255.255.0”</span><br></pre></td></tr></table></figure><br>修改<strong>/etc/yum.repos.d/CentOS-Base.repo</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[base]</span><br><span class="line">...</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra</span><br><span class="line">baseurl=http://vault.centos.org/centos/$releasever/os/$basearch/</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[updates]</span><br><span class="line">...</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra</span><br><span class="line">baseurl=http://vault.centos.org/centos/$releasever/updates/$basearch/</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[extras]</span><br><span class="line">...</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra</span><br><span class="line">baseurl=http://vault.centos.org/centos/$releasever/extras/$basearch/</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[centosplus]</span><br><span class="line">...</span><br><span class="line">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra</span><br><span class="line">baseurl=http://vault.centos.org/centos/$releasever/centosplus/$basearch/</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>本人在上述操作后可以成功安装gcc环境，若还是出现问题，可以查看别人的解决方案。</p><h2 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>压缩包下载<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><br>将压缩包转移到所建目录并解压<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/java</span><br><span class="line">mv redis-6.2.6.tar.gz /usr/java</span><br><span class="line">cd /usr/java</span><br><span class="line">tar -zxf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><br>编译并下载Redis<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.6</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><br>将配置文件移动并修改配置文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">cp /usr/java/redis-6.2.6/redis.conf ./</span><br><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure><br>修改redis.conf<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">...</span><br><span class="line">daemonize yes</span><br><span class="line">requirepass ****(密码)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>第一次启动Redis测试<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./redis-server redis.conf</span><br><span class="line"></span><br><span class="line">./redis-cli</span><br><span class="line">若出现</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line">则证明redis启动成功</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; exit </span><br><span class="line">退出redis,配置后续</span><br></pre></td></tr></table></figure><br>配置防火墙<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br><span class="line"></span><br><span class="line">出现success则为成功</span><br></pre></td></tr></table></figure><br>重启防火墙<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure></p><h1 id="设置开机自启动（设置自启动成功则final-shell连接不上，final-shell连接成功则不能开机自启，放弃）"><a href="#设置开机自启动（设置自启动成功则final-shell连接不上，final-shell连接成功则不能开机自启，放弃）" class="headerlink" title="设置开机自启动（设置自启动成功则final shell连接不上，final shell连接成功则不能开机自启，放弃）"></a>设置开机自启动（设置自启动成功则final shell连接不上，final shell连接成功则不能开机自启，放弃）</h1><p>新建系统服务文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><br>将下面内容写入<strong>redis.service</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line"># 这行配置内容要根据redis的安装目录自定义路径</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/bin/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><br>在<strong>/etc/redis/redis.conf</strong>文件中添加<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervised no</span><br></pre></td></tr></table></figure><br>执行下面命令测试服务<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start redis</span><br></pre></td></tr></table></figure><br>执行命令重新加载<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><br>设置开机自启动<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable redis</span><br></pre></td></tr></table></figure><br>查看redis状态<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><br><img src="/2024/09/22/2024-9-22-%E5%85%B3%E4%BA%8E%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%83%A8%E7%BD%B2Redis/image.png" alt="redis状态"><br>出现上图即为设置成功。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么lua可以保证原子性</title>
      <link href="/2024/09/20/2024-9-20-%E4%B8%BA%E4%BB%80%E4%B9%88lua%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
      <url>/2024/09/20/2024-9-20-%E4%B8%BA%E4%BB%80%E4%B9%88lua%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在学习Redis的分布式锁时，课中说明需要使用Lua脚本编写setnx来实现分布式锁，而不把setnx直接写在Java中，是因为在Java代码中会存在极端情况。<br>我们有两个线程，分别时<strong>线程1</strong>和<strong>线程2</strong>。我们在设置分布式锁时，已经设置了标识，每个锁都有一个唯一标识。线程1获取了锁，在线程1释放时我们要判断锁标识是不是自己的，是自己的才能释放。但是在判断结束还没释放锁的时候，Java虚拟机触发了Full GC,执行stw,线程1就被卡住了。（当然一般这种情况不会发生）让我们再极端一点，Full GC的时间足够长，撑到了线程1的超时释放，线程1的锁就被自动释放了。<br>既然线程1的锁被自动释放了，线程2就可以获取到锁。但是足够巧，Full GC在恰当的时间结束了，线程1又自由了。前面我们提到，线程1已经判断了锁标识，所以它不会再判断一遍，于是线程1把属于线程2的锁释放掉，发生了并发问题。<br>为了避免这个极端的问题，课中引入了lua脚本来编写setnx来保证线程的原子性。<br>那么问题来了，为什么lua脚本可以保证线程的原子性呢？<br>在使用lua时，Redis采用了单线程模型，也就是说，当Redis执行lua脚本时，其他客户端的请求都必须等待lua脚本执行完毕后才能执行。这就保证了lua脚本的原子性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于编译器的一些小技巧</title>
      <link href="/2024/09/05/2024-9-5-%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/09/05/2024-9-5-%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h3 id="快速通过请求定位代码"><a href="#快速通过请求定位代码" class="headerlink" title="快速通过请求定位代码"></a>快速通过请求定位代码</h3><p>在idea中双击shift,可以调出搜索框，这时输入你想查找的URL就可以直接定位到相应的方法。<br><img src="https://ranni.s3.bitiful.net/idea1.png" alt="idea小妙招1.1" title="idea小妙招1.1"><br><img src="https://ranni.s3.bitiful.net/idea2.png" alt="idea小妙招1.2" title="idea小妙招1.2"></p><h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p><strong>ctrl+alt+l</strong></p><h3 id="从代码中抽取方法"><a href="#从代码中抽取方法" class="headerlink" title="从代码中抽取方法"></a>从代码中抽取方法</h3><p><strong>ctrl+alt+m</strong></p><h3 id="将代码块整体左移或右移"><a href="#将代码块整体左移或右移" class="headerlink" title="将代码块整体左移或右移"></a>将代码块整体左移或右移</h3><p>左：选中代码块，<strong>shift+table</strong><br>右：选中代码块，<strong>table</strong></p><h3 id="快速生成try-catch代码块"><a href="#快速生成try-catch代码块" class="headerlink" title="快速生成try-catch代码块"></a>快速生成try-catch代码块</h3><p><strong>ctrl+alt+t</strong></p><h3 id="小写转大写"><a href="#小写转大写" class="headerlink" title="小写转大写"></a>小写转大写</h3><p><strong>ctrl+shift+u</strong></p><h2 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h2><h3 id="格式化代码-1"><a href="#格式化代码-1" class="headerlink" title="格式化代码"></a>格式化代码</h3><p><strong>shift+alt+f</strong></p><h2 id="git-bash"><a href="#git-bash" class="headerlink" title="git bash"></a>git bash</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><strong>ctrl + insert</strong></p><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p><strong>shift + insert</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于sql的一些学习</title>
      <link href="/2024/09/05/2024-9-5-%E5%85%B3%E4%BA%8Esql%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/09/05/2024-9-5-%E5%85%B3%E4%BA%8Esql%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="关于trim标签的使用"><a href="#关于trim标签的使用" class="headerlink" title="关于trim标签的使用"></a>关于trim标签的使用</h2><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>属性</strong></th><th style="text-align:center"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">prefix</td><td style="text-align:center">给sql语句拼接的前缀</td></tr><tr><td style="text-align:left">suffix</td><td style="text-align:center">给sql语句拼接的后缀</td></tr><tr><td style="text-align:left">prefixOverrides</td><td style="text-align:center">去除sal语句前面的关键字或者字符，该关键字或者字符由prefxOverrides属性指定，假设该属性指定为”AND”，当sql语句的开头为”AND”，trim标签将会去除该”AND”</td></tr><tr><td style="text-align:left">suffixOverrides</td><td style="text-align:center">去除sql语句后面的关键字或者字符，该关键字或者字符由suffixOverrides属性指定</td></tr></tbody></table></div><p>例如下面的sql语段<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>trim prefix<span class="operator">=</span>&quot;(&quot; suffix<span class="operator">=</span>&quot;)&quot; suffixOverrides<span class="operator">=</span>&quot;,&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;id != null&quot;<span class="operator">&gt;</span>id,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;name != null&quot;<span class="operator">&gt;</span>name,<span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line"> <span class="operator">&lt;</span><span class="operator">/</span>trim<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><br>就是在sql中将前缀拼接为”(“，后缀拼接为”)”，并且去除后缀的”,”。</p><h2 id="关于sql语句的解耦"><a href="#关于sql语句的解耦" class="headerlink" title="关于sql语句的解耦"></a>关于sql语句的解耦</h2><p>在sql编写中，我们可以将多次出现的sql语句进行抽离并调用，这样大大降低了sql的耦合度<br>例如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name, parent_id <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line"><span class="keyword">select</span> id, name, parent_id <span class="keyword">from</span> test <span class="keyword">where</span> name <span class="operator">=</span> #&#123;name&#125;</span><br></pre></td></tr></table></figure><br>以上的sql可以抽离为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">sql</span> id<span class="operator">=</span>&quot;selectTest&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> id, name, parent_id <span class="keyword">from</span> test</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">sql</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectById&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;selectTest&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">where</span> id <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;selectByName&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;selectTest&quot;<span class="operator">/</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">where</span> name <span class="operator">=</span> #&#123;name&#125;  </span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span>    </span><br></pre></td></tr></table></figure></p><h2 id="关于distinct关键字"><a href="#关于distinct关键字" class="headerlink" title="关于distinct关键字"></a>关于distinct关键字</h2><p>在sql语句中，我们可以使用distinct关键字来去除重复的记录<br>例如有下表<br><img src="https://ranni.s3.bitiful.net/distinct1.1.png" alt="distinct演示1.1" title="distinct演示1.1"><br>当我们使用distinct查询表时，返回的表数据会自动去重<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name, age <span class="keyword">from</span> test</span><br></pre></td></tr></table></figure><br><img src="https://ranni.s3.bitiful.net/distinct1.2.png" alt="distinct演示1.2" title="distinct演示1.2"><br>其中重复的Alice记录就只能显示一个了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于git</title>
      <link href="/2024/08/25/2024-8-25-%E5%85%B3%E4%BA%8Egit/"/>
      <url>/2024/08/25/2024-8-25-%E5%85%B3%E4%BA%8Egit/</url>
      
        <content type="html"><![CDATA[<h2 id="获取仓库"><a href="#获取仓库" class="headerlink" title="获取仓库"></a>获取仓库</h2><h3 id="1-获取本地仓库"><a href="#1-获取本地仓库" class="headerlink" title="1.获取本地仓库"></a>1.获取本地仓库</h3><p>在需要创建仓库的文件夹中打开git bash,并输入<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p><h3 id="2-获取线上仓库"><a href="#2-获取线上仓库" class="headerlink" title="2.获取线上仓库"></a>2.获取线上仓库</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;项目地址&gt;</span><br></pre></td></tr></table></figure><h2 id="仓库相关指令"><a href="#仓库相关指令" class="headerlink" title="仓库相关指令"></a>仓库相关指令</h2><h3 id="1-本地仓库"><a href="#1-本地仓库" class="headerlink" title="1.本地仓库"></a>1.本地仓库</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git status                查看仓库状态</span><br><span class="line">git add                   添加所有文件到暂存区</span><br><span class="line">git reset                 撤销暂存区文件</span><br><span class="line">git reset --hard          回退到指定版本</span><br><span class="line">git commit -m &quot;提交信息&quot;   提交暂存区文件到本地仓库</span><br><span class="line">git log                   查看提交历史</span><br></pre></td></tr></table></figure><h3 id="2-线上仓库"><a href="#2-线上仓库" class="headerlink" title="2.线上仓库"></a>2.线上仓库</h3><p>当同事A上传了代码后，同事B使用clone获取代码。在获取代码后我们可以对代码进行更新。更新后同事B可以直接push代码到托管平台，同事A想查看更新可以直接pull代码,不需要再进行clone.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote                      查看远程仓库</span><br><span class="line">git remote add origin &lt;项目地址&gt; 添加远程仓库</span><br><span class="line">git clone &lt;项目地址&gt;             从远程仓库克隆到本地</span><br><span class="line">git pull                        从远程仓库拉取最新代码</span><br><span class="line">git push                        推送本地代码到远程仓库</span><br></pre></td></tr></table></figure></p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch                    查看分支</span><br><span class="line">git branch &lt;分支名&gt;            创建分支</span><br><span class="line">git checkout &lt;分支名&gt;          切换分支</span><br><span class="line">git push origin &lt;分支名&gt;       推送分支到远程仓库</span><br><span class="line">git merge &lt;分支名&gt;             合并分支</span><br><span class="line">git branch -d &lt;分支名&gt;         删除分支</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git tag                           查看标签</span><br><span class="line">git tag &lt;标签名&gt;                   创建标签</span><br><span class="line">git tag -a &lt;标签名&gt; -m &quot;标签信息&quot;  创建带注释的标签</span><br><span class="line">git push origin &lt;标签名&gt;           推送标签到远程仓库</span><br><span class="line">git checkout -b &lt;分支名&gt; &lt;标签名&gt;  创建分支并切换到标签</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于redis使用场景</title>
      <link href="/2024/08/05/2024-8-5-%E5%85%B3%E4%BA%8Eredis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2024/08/05/2024-8-5-%E5%85%B3%E4%BA%8Eredis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="关于redis常用的数据类型"><a href="#关于redis常用的数据类型" class="headerlink" title="关于redis常用的数据类型"></a>关于redis常用的数据类型</h2><p><strong>String</strong>: 字符串。 set key value  ;  get key </p><p><strong>Hash</strong>:键值对集合，存储多个字段。 hset key field value  ;  hget key field ; hmset key field1 value1 field2 value2  ;  hmget key field1 field2 (存储/获取一个或多个哈希是键值对的集合) </p><p><strong>List</strong>：列表，按插入顺序排序。 lpush key value  ;  rpush key value  ;(插入元素到列表的头部/尾部)   lpop key  ;  rpop key  (从头/尾删除一个元素)  lrange key start end  (获取列表指定范围的元素) </p><p><strong>Set</strong>：集合，无序不重复。 sadd key value  ;  srem key value  ;  smembers key  (添加/删除元素到集合/获取集合所有元素) </p><p><strong>Zset</strong>：有序集合 每个元素都会关联double类型的分数，元素唯一但是分数可以重复。 zadd key score value  ;  zrem key value  ;  zrange key start end  (添加/删除元素到有序集合/获取有序集合指定范围的元素) zscore key value  (获取元素的分数) </p><h2 id="关于击穿，穿透，雪崩"><a href="#关于击穿，穿透，雪崩" class="headerlink" title="关于击穿，穿透，雪崩"></a>关于击穿，穿透，雪崩</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>用户在查找不存在的数据时，因为缓存中没有，所以每一次只要有查找操作时缓存都会向数据库发送查找请求，极大的增加了数据库的压力。<br>解决方案：<br>1.缓存空对象：当缓存和数据库都查不到某个数据时，我们可以将其查找的数据在redis中缓存为一个空对象，这样下次再访问时，就可以直接返回空对象，避免了多次请求。<br>2.布隆过滤器：布隆过滤器是一种数据结构，它可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>我们在做缓存时为某一个key设置了过期时间，当该key过期时恰好有大量该key的并发请求，会给数据库造成很大压力。<br>解决方案：<br>1.设置热点数据永不过期：对于热点数据，我们可以设置永不过期，这样即使缓存过期，也能保证热点数据能够及时更新。<br>2.使用互斥锁：当缓存失效时，使用互斥锁，只有一个线程去更新缓存，其他线程等待。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存服务器重启或者大量缓存同时失效时，会给数据库造成很大压力。<br>解决方案：<br>1.给不同的key添加随机的失效时间。<br>2.使用Redis集群：Redis集群可以将数据分布到不同的服务器上，避免单点故障。<br>3.给缓存业务添加降级限流策略。<br>4.给业务添加多级缓存。</p><h2 id="双写一致性（mysql和redis数据同步）"><a href="#双写一致性（mysql和redis数据同步）" class="headerlink" title="双写一致性（mysql和redis数据同步）"></a>双写一致性（mysql和redis数据同步）</h2><p>修改数据库的数据的同时也要更新缓存的数据，缓存和数据库的数据要保持一致。<br><strong>一致性要求高</strong>：<br><strong>允许延迟一致</strong>：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于线程池的问题</title>
      <link href="/2024/08/01/2024-8-1-%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/01/2024-8-1-%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池执行原理"><a href="#线程池执行原理" class="headerlink" title="线程池执行原理"></a>线程池执行原理</h2><h3 id="线程池参数设置"><a href="#线程池参数设置" class="headerlink" title="线程池参数设置"></a>线程池参数设置</h3><p>1.corePoolSize 核心线程数，默认是cpu核数。<br>2.maximumPoolSize 最大线程数，默认是Integer.MAX_VALUE。<br>3.keepAliveTime 非核心线程空闲时间，默认60s。<br>4.unit 时间单位，默认TimeUnit.SECONDS。<br>5.workQueue 阻塞队列，默认是LinkedBlockingQueue。<br>6.threadFactory 线程工厂，默认是DefaultThreadFactory。</p><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><p>当我们提交任务时，要先判断<strong>核心线程</strong>是否已满，若没满则添加到工作线程并执行，若满了则判断<strong>阻塞队列</strong>是否已满，若没满则把任务添加到阻塞队列，若满了则判断线程数是否小于最大线程数，若小于则我们使用<strong>非核心线程</strong>来处理最新的任务，处理后<strong>非核心线程</strong>会检查阻塞队列中是否有要执行的线程，若有则处理。若线程数大于最大线程数，则使用拒绝策略。<br>拒绝策略分四点：<br>1.AbortPolicy:直接抛出异常，默认。<br>2.CallerRunsPolicy:由调用者所在的线程来执行任务。<br>3.DiscardOldestPolicy:丢弃阻塞队列中最靠前的任务，并执行当前任务。<br>4.DiscardPolicy:直接丢弃任务，不处理。<br><img src="https://ranni.s3.bitiful.net/threadpool—Executionprinciple.png" alt="线程池执行原理" title="线程池执行原理"></p><h2 id="关于阻塞队列"><a href="#关于阻塞队列" class="headerlink" title="关于阻塞队列"></a>关于阻塞队列</h2><p>阻塞队列一共有四个<br>1.<strong>ArrayBlockingQueue</strong> 基于数组的有界阻塞队列，<strong>FIFO</strong><br>2.<strong>LinkedBlockingQueue</strong> 基于链表的阻塞队列，<strong>FIFO</strong><br>3.PriorityBlockingQueue  优先级队列，保证执行的任务是队列中最靠前的<br>4.DelayQueue  不存储元素，插入新任务必须等上一个任务完成并移出。</p><table>    <thead>        <tr>            <th><strong>ArrayBlockingQueue</strong></th>            <th><strong>LinkedBlockingQueue</strong></th>        </tr>    </thead>    <tbody>        <tr>            <td>强制规定大小</td>            <td>不强制规定大小，规定也行</td>        </tr>        <tr>            <td>由<strong>数组</strong>构成</td>            <td>由<strong>链表</strong>构成</td>        </tr>        <tr>            <td>提前初始化Node数组</td>            <td>创建节点时添加数据</td>        </tr>        <tr>            <td>Node数组提前创建</td>            <td>数据入队生成新Node</td>        </tr>        <tr>            <td>一把锁</td>            <td>两把锁（头尾）</td>        </tr>    </tbody></table><h2 id="确定核心线程数"><a href="#确定核心线程数" class="headerlink" title="确定核心线程数"></a>确定核心线程数</h2><p>1 在高并发且任务执行时间短 -&gt; <strong>cpu核数+1</strong>，减少上下文切换<br>2 并发不高但任务执行时间长<br>    · IO密集型任务 -&gt; <strong>cpu核数*2+1</strong><br>    · 计算密集型任务 -&gt; <strong>cpu核数+1</strong><br>3 并发高且任务执行时间长 -&gt; 这类任务就不是设置线程池能够解决的了，首先尝试为数据作缓存，其次增加服务器。</p><h2 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h2><p>1.FixedThreadPool 固定线程池，线程数量固定，任务按照提交顺序执行，超出的线程会在队列中等待。<br>2.SingleThreadExecutor 单线程线程池，只有一个线程，任务按照提交顺序执行。<br>3.CachedThreadPool 缓存线程池，没有核心线程，只有非核心线程，且线程数量不固定，空闲线程会被回收（能够存活60S），任务按照提交顺序执行。<br>4.ScheduledThreadPool 定时线程池，线程数量不固定，任务按照延迟时间执行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于线程安全问题</title>
      <link href="/2024/07/30/2024-7-30-%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/30/2024-7-30-%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h2><p>synchronized是互斥锁，同一时刻只有一个线程能持有对象锁，synchronized基于monitor实现，修饰代码块时会使用monitorenter和monitorexit指令，当一个线程执行monitorenter指令时，会尝试获取对象的锁，如果成功，则执行代码块，执行完毕后释放锁，如果失败，则阻塞线程，直到锁被释放。monitor中由waitset,entrylist,owner组成。owner中存储获取对象锁的线程，只有一个线程在owner里面，entrylist中存放的是没有抢到锁的线程，当owner里面没有线程的时候entrylist里面的线程会进行争抢，最后抢到锁的线程进入owner，其他线程仍然在entrylist处于阻塞状态。waitset中存放的是调用了wait方法的线程。</p><h3 id="synchronized和lock区别"><a href="#synchronized和lock区别" class="headerlink" title="synchronized和lock区别"></a>synchronized和lock区别</h3><p>synchronized是Java关键字,由C++实现，lock是java.util.concurrent包下的类。使用synchronized时退出同步代码块锁会自动释放，使用lock时需手动调用unlock释放锁。<br>二者都属于悲观锁，但是lock提供了比synchronized更高级的功能，比如可中断锁、超时锁、条件变量等。<br>在没有竞争时synchronized做了很多优化，在竞争激烈时lock会有更优秀的性能。</p><h2 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM(Java内存模型)"></a>JMM(Java内存模型)</h2><p>JMM是Java的内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过规则来规范内存读写操作从而保证指令正确性。<br>JMM把内存分成两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）。<br>线程和线程之间相互隔离，交互需要通过主内存实现。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>乐观锁顾名思义，心态比较乐观，觉得运行时不会有冲突，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是如果有冲突，就只能重试，直到成功为止。CAS(Compare And Swap)就是一种乐观锁的实现。<br>悲观锁，心态比较悲观，认为运行时会有冲突，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。synchronized就是悲观锁的一种实现。</p><h3 id="CAS的原理"><a href="#CAS的原理" class="headerlink" title="CAS的原理"></a>CAS的原理</h3><p>CAS主要在无锁状态下保证线程操作的原子性。使用自旋锁，线程没有阻塞，效率高。底层调用Unsafe方法。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>1.volatile可以保证线程的可见性，阻止编译器优化的发生，让一个线程对共享变量的修改对另一个线程可见。<br>2.volatile可以阻止指令的重排序，在读，写变量时加入屏障，阻止其他读写操作越过屏障。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>AQS是多线程中的队列同步器，ReentrantLock和Semaphore都是基于AQS实现的。AQS的内部有一个FIFO的队列，队列中存储的是排队的线程。在AQS中还有一个state属性，用来标识共享资源的状态。默认为0（无锁）如果队列中有一个线程将state设置为1（加锁），则其他线程只能阻塞等待。在对state进行修改时，需要使用CAS来保证原子性。且AQS可以实现公平锁，也可以实现非公平锁。取决于新线程是否和队列的第一个线程抢资源。抢就是非公平锁，直接排到队列末尾就是公平锁。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReetrantLock主要基于CAS+AQS实现，支持公平锁和非公平锁。构造方法可以指定公平锁和非公平锁。公平参数默认为true时为公平锁。公平锁的效率没有非公平锁高。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>线程抢到锁后使用CAS修改state为1，让exclusiveOwnerThread属性指向当前线程，获取锁成功。若修改状态失败，则会进入双向队列等待。head指向队列头，tail指向队列未。当exclusiveOwenrThread为null时，则会唤醒双向队列中的等待线程。</p><h2 id="多线程死锁"><a href="#多线程死锁" class="headerlink" title="多线程死锁"></a>多线程死锁</h2><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><p>互斥条件：资源不能被多线程共享，一次只能由一个线程使用。若一个线程已经占用了某个资源，其他线程必须等待。<br>不可抢占条件：资源只能由拥有者释放，不能被其他线程强行抢占。<br>请求与保持条件：线程因请求资源而阻塞时，对已获得的资源保持不放。<br>循环等待条件：若资源的拥有线程在等待时，发生了资源的再次请求，则产生循环等待。</p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>互斥死锁无法改变<br>1.破坏不可抢占条件：若占用资源的线程进一步申请其他资源，则必须释放当前资源。<br>2.破坏请求与保持条件：一次性申请所有资源。<br>3.破坏循环等待条件：对资源进行排序，强制资源按顺序申请。</p><h3 id="死锁判断"><a href="#死锁判断" class="headerlink" title="死锁判断"></a>死锁判断</h3><p>出现死锁可以使用jdk自带的工具来判断 ： jps 和 jstack</p><h2 id="Java中保证多线程执行安全（Java并发三大特性）"><a href="#Java中保证多线程执行安全（Java并发三大特性）" class="headerlink" title="Java中保证多线程执行安全（Java并发三大特性）"></a>Java中保证多线程执行安全（Java并发三大特性）</h2><p><strong>原子性</strong> 线程在操作中不可暂停也不可中断，要么不执行，要么完成。<br>要保证其可见性需要使用synchronized加锁。<br><strong>可见性</strong> 一个线程对共享变量的修改，其他线程立即可以看到。<br>要保证可见性可以用volatile关键字。<br><strong>有序性</strong> 程序执行的顺序按照代码的先后顺序执行。<br>synchronized或者volatile都可以保证多线程之间操作的有序性。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于多线程的基础问题</title>
      <link href="/2024/07/28/2024-7-28-%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/28/2024-7-28-%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p>进程是计算机资源分配的基本单位，线程是CPU调度的基本单位，一个进程中包含了多个线程来完成不同的任务。不同的进程会使用不同的内存空间，在同一个进程中的所有线程可以共享内存空间。线程相对来说更轻量化，线程的上下文切换要比进程的切换效率高。</p><h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p>并发是计算机在同一时间应对多个事情，线程轮流使用CPU。<br>并行是计算机在同一时间做多个事情，多个线程同时使用CPU。</p><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol><li>继承Thread类创建线程</li><li>实现Runnable接口创建线程</li><li>实现Callable接口创建线程</li><li>线程池创建线程<h3 id="runnable和callable的区别"><a href="#runnable和callable的区别" class="headerlink" title="runnable和callable的区别"></a>runnable和callable的区别</h3>Runnable接口中run()方法没有返回值，而Callable接口中call()方法有返回值,是泛型，和Future、FutureTask配合使用可以实现异步调用。<br>同时Callable接口的call()方法允许抛出异常，而Runnable的run()方法的异常只能内部解决。<h3 id="run-和start-的区别"><a href="#run-和start-的区别" class="headerlink" title="run()和start()的区别"></a>run()和start()的区别</h3>start()用来启动线程，通过该线程调用run方法执行run方法中定义的代码，start()方法只能被调用一次<br>run()封装了要被线程执行的代码，可调用多次。</li></ol><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程主要有六种状态，分别为<strong>NEW</strong>, <strong>RUNNABLE</strong>, <strong>BLOCKED</strong>, <strong>WAITING</strong>, <strong>TIMED_WAITING</strong>, <strong>TERMINATED</strong>。</p><ul><li>NEW：线程刚被创建，尚未启动。</li><li>RUNNABLE：线程正在执行。</li><li>BLOCKED：线程被阻塞，A线程执行时加锁，B线程就是阻塞状态，需要等A线程执行完毕后才能执行B线程。</li><li>WAITING：线程在等待另一个线程执行特定操作。</li><li>TIMED_WAITING：线程在等待另一个线程执行特定操作，但是有一个时间限制。</li><li>TERMINATED：线程已经执行完毕。</li></ul><h3 id="线程状态转化"><a href="#线程状态转化" class="headerlink" title="线程状态转化"></a>线程状态转化</h3><p>首先创建线程（新建），调用start()方法变成可执行状态，执行完毕后是终止状态。<br>在可执行状态中如果另一个线程加锁则进入阻塞状态，该线程获得锁之后才可执行。<br>如果线程调用了wait()方法则进入等待状态，需其他线程调用notify()方法通知后才能继续执行。<br>如果线程调用了sleep()方法则进入时间等待状态，经过一段时间后自动转化为RUNNABLE状态。</p><h2 id="如何保证多线程之间的执行顺序"><a href="#如何保证多线程之间的执行顺序" class="headerlink" title="如何保证多线程之间的执行顺序"></a>如何保证多线程之间的执行顺序</h2><p>调用join()方法，假设有t1,t2,t3三个线程。如果我们想让线程按123的顺序走，则我们可以在创建t2线程时使用t1.join()方法，在创建t3线程时使用t2.join()方法，这样就保证了只有t1执行完毕后才会执行t2,t2执行完毕后才会执行t3。</p><h2 id="notify-和notifyAll-的区别"><a href="#notify-和notifyAll-的区别" class="headerlink" title="notify()和notifyAll()的区别"></a>notify()和notifyAll()的区别</h2><p>notify()方法只唤醒一个随机线程<br>notifyAll()方法唤醒所有等待该对象的线程。</p><h2 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h2><p>相同点：wait()和sleep()都可以让线程暂停执行一段时间,进入阻塞状态<br>不同点：<br>1.sleep()方法时Thread类中的静态方法，而wait()方法时Object类中的成员方法，每个对象都可以调用。<br>2.sleep(long)和wait(long) 方法中只要（）中规定了参数，则会在相应的时间醒来。如果只是wait()方法则会一直沉睡，直到使用notify()方法唤醒<br>3.wait必须要先获取wait对象的锁才可以调用，而sleep无限制。wait方法执行后会释放对象锁，允许其他线程获取锁。sleep如果在synchronized代码块中执行，则不会释放锁。</p><h2 id="打断运行时的线程"><a href="#打断运行时的线程" class="headerlink" title="打断运行时的线程"></a>打断运行时的线程</h2><p>1.使用退出标志，可以定义一个bollean类型的变量，用来判断线程是否需要退出。<br>2.使用stop强制停止，不推荐<br>3.使用interrupt()方法中断线程。可以打断正常运行的线程，也可以打断处于wait,sleep,join状态的线程，会抛出InterruptedException异常。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Mybatis的一些问题</title>
      <link href="/2024/07/24/2024-7-24-%E5%85%B3%E4%BA%8EMybatis%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/24/2024-7-24-%E5%85%B3%E4%BA%8EMybatis%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="关于Mybatis"><a href="#关于Mybatis" class="headerlink" title="关于Mybatis"></a>关于Mybatis</h2><p>Mybatis是一个半ORM(对象关系映射)的框架，内部封装了JDBC,使用时可只注意便携SQL语句，不需要手动创建链接等操作。但是SQL语句编写工作量大，且不能随意更改数据库。</p><h2 id="关于Mybatis的执行流程"><a href="#关于Mybatis的执行流程" class="headerlink" title="关于Mybatis的执行流程"></a>关于Mybatis的执行流程</h2><p>首先在maven中我们导入了mybatis-spring-boot的起步依赖，然后在application.properties/application.yml中配置了mybatis的相关配置，包括mybatis的配置文件路径、数据库连接信息等。创建完依赖后我们会构建会话工厂SqlSessionFactory，然后我们就可以通过SqlSessionFactory来创建会话对象，然后我们操作数据库接口，Executor执行器，同时负责查询缓存的维护。Executor接口中有MappedStatement类型的参数，封装了映射信息。最后我们输入参数映射并等待输出结果映射。（说实话没听懂）</p><h2 id="关于Mybatis传递多个参数"><a href="#关于Mybatis传递多个参数" class="headerlink" title="关于Mybatis传递多个参数"></a>关于Mybatis传递多个参数</h2><p>1.参数可以像数组一样用下标传递，如#{0}则代表传递第0个参数<br>2.可以使用@<strong>Param</strong>注释来指定参数，在方法中例如public void addUser(@Param(“name”) String name, @Param(“age”) int age)来对参数进行标注，当需要的时候直接在SQL语句中注入，例如 select * from user where name = #{name} and age = #{age}<br>3.使用Map传递参数<br>4.可以直接使用bean对象作为参数，例如User user，然后在SQL语句中直接使用#{user.name}来引用属性值</p><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h2><p>在使用#{}时，Mybatis会在SQL执行前将占位符替换为 ? ,并使用参数值来代替 ? 。<br>在使用${}时，参数的值会直接替换到SQL语句中，不会进行任何处理。例如参数是<strong>1 or 1=1</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> $&#123;id&#125;</span><br><span class="line">例如输入的参数是<span class="operator">*</span><span class="operator">*</span><span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="operator">*</span><span class="operator">*</span>,则<span class="keyword">SQL</span>会变成</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">会导致查询所有用户的结果</span><br></pre></td></tr></table></figure><br>所以我们一般推荐使用#{}</p><h2 id="关于Mybatis的延迟加载"><a href="#关于Mybatis的延迟加载" class="headerlink" title="关于Mybatis的延迟加载"></a>关于Mybatis的延迟加载</h2><p>延迟加载就是在需要用到该数据时才会进行加载，不用就不加载，可以提高性能。但是延迟加载在mybatis中是默认关闭的。<br>Mabatis的延迟加载主要是使用了CGLIB创建目标对象的代理对象，调用目标方法时首先会进入拦截器invoke方法。如果拦截器发现目标方法get到的值为null,就证明这个数据还没被加载，这时才会执行sql语句。获取数据后再把代理对象中的值set进目标对象中。</p><h2 id="关于Mybatis的二级缓存"><a href="#关于Mybatis的二级缓存" class="headerlink" title="关于Mybatis的二级缓存"></a>关于Mybatis的二级缓存</h2><p>一级缓存是基于PerpetualCache的HashMap的本地缓存，作用域为session,session flush或者close后就会把cache清空，mybatis默认开启一级缓存。<br>二级缓存也是基于PerpetualCache的HashMap的本地缓存，但是二级缓存不依赖session，也就是说，同一个SqlSession的查询，即使不关闭，二级缓存也会存在。mybatis默认不开启二级缓存。<br>在一级或二级缓存进行<strong>增删改</strong>操作后，默认将该作用域的缓存清空。</p><h2 id="关于Mybatis的批量加载"><a href="#关于Mybatis的批量加载" class="headerlink" title="关于Mybatis的批量加载"></a>关于Mybatis的批量加载</h2><p>1.使用<strong>foreach</strong>标签<br>使用foreach标签进行遍历，将collection的属性值改成目标参数的属性值，然后在SQL语句中使用#{item}来引用属性值。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><br>2.使用<strong>batch批处理</strong>方法<br>不太熟悉。</p><h2 id="关于Mybatis实现分页"><a href="#关于Mybatis实现分页" class="headerlink" title="关于Mybatis实现分页"></a>关于Mybatis实现分页</h2><p>1.我们可以运用分页拦截器，拦截待执行的SQL，然后在SQL语句中添加分页的相关参数，然后再执行SQL。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拦截前</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line">拦截后</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student limit #&#123;page&#125;,#&#123;size&#125;</span><br></pre></td></tr></table></figure><br>2.我们也可以使用PageHelper实现分页。我们引入PageHelper依赖，然后在配置文件中配置PageHelper的相关参数。然后我们就可以在方法中直接调用PageHelper的startPage（page,size）来实现分页。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring的一些问题</title>
      <link href="/2024/07/20/2024-7-20-%E5%85%B3%E4%BA%8ESpring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/20/2024-7-20-%E5%85%B3%E4%BA%8ESpring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="单例bean是线程安全的吗"><a href="#单例bean是线程安全的吗" class="headerlink" title="单例bean是线程安全的吗"></a>单例bean是线程安全的吗</h2><p>Spring 的单例bean不是线程安全的。如果bean中定义了可修改的成员变量，就可能会有其他线程对其进行修改，所以线程不是安全的。我们可以把单例的bean修改成多例模式或者加锁来解决。</p><h2 id="关于AOP"><a href="#关于AOP" class="headerlink" title="关于AOP"></a>关于AOP</h2><p>AOP是面向切面编程，主要是把公共模块抽离代码，降低耦合。</p><h3 id="项目中有没有用到AOP"><a href="#项目中有没有用到AOP" class="headerlink" title="项目中有没有用到AOP?"></a>项目中有没有用到AOP?</h3><p>用到过，主要是使用环绕通知和切点的方式，对controller中的方法进行参数拦截，获取到参数后进行判断，如果不满足aop定义的规则则调用自己定义的错误方法报错。</p><h2 id="关于Spring事务"><a href="#关于Spring事务" class="headerlink" title="关于Spring事务"></a>关于Spring事务</h2><p>Spring事务主要分为两种，编程式事务和声明式事务。其中编程式事务需使用方法实现，对业务代码有入侵性，很少使用。而声明式事务是建立在AOP之上的，主要是通过AOP对方法前后进行拦截，方法执行完后根据运行情况进行提交或回滚。</p><h3 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h3><p>事务失效有很多种情况。首先是<strong>异常捕获处理不当</strong>会导致事务失效。在trycatch中如果我们自己处理了异常，事务无法得知，则会出现事务失效。正确的解决方法是将异常抛出，让事务知晓代码出了异常，从而进行回滚。其次是Spring默认只会回滚<strong>非检查异常</strong>，在方法中定义了检查类异常会导致事务不知道出现了异常，从而无法回滚。我们可以配置rollback属性为受检异常定义回滚。最后Spring的事务只能对Public的方法使用，如果方法是private，则无法使用事务。</p><h2 id="关于Spring-bean"><a href="#关于Spring-bean" class="headerlink" title="关于Spring bean"></a>关于Spring bean</h2><p>Spring bean的生命周期： 主要分为<strong>实例化</strong>，<strong>属性赋值</strong>，<strong>初始化</strong>，<strong>销毁</strong>四个阶段。<br>实例化：Spring容器在加载bean时，会实例化bean，并调用bean的构造方法，将bean的依赖注入到bean中。<br>属性赋值：Spring容器会调用set方法将属性值注入到bean中。<br>初始化：Spring容器会调用bean的初始化方法，完成bean的一些初始化工作。<br>销毁：当容器关闭时，Spring会调用bean的销毁方法，完成一些资源的释放。</p><h3 id="bean的定义方法即依赖注入"><a href="#bean的定义方法即依赖注入" class="headerlink" title="bean的定义方法即依赖注入"></a>bean的定义方法即依赖注入</h3><p>关于bean的<strong>定义</strong>，spring有三种方法。<br>1.xml文件定义：通过xml文件定义bean，并通过标签属性来设置bean的属性值。<br>2.注解定义：通过注解来定义bean，并通过注解的属性来设置bean的属性值。主要有@Component、@Service、@Repository、@Controller四个注解。<br>3.java配置：通过java配置类来定义bean，并通过@Bean注解来设置bean的属性值。</p><p>关于Bean依赖的注入，spring中也有三种方法。<br>1.构造方法注入：通过构造方法注入，Spring容器会自动调用构造方法，并将依赖注入到bean中。<br>例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyRepository myRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">(MyRepository myRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myRepository = myRepository;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.setter方法注入：通过setter方法注入，Spring容器会自动调用setter方法，并将依赖注入到bean中。<br>例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMyRepository</span><span class="params">(MyRepository myRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myRepository = myRepository;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.注解注入：通过注解@Autowired，@Resource，Spring容器会自动注入依赖。<br>关于@Autowired和@Resource，他们两个虽然都是用来注入依赖的，但是有一定差别。@Autowired是spring所提供的注入方法，默认byType注入，可以用在构造方法、方法、字段上。@Resource是J2EE提供的注入方法，默认byName注入，只能用在字段上。<br>例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="bean的循环依赖"><a href="#bean的循环依赖" class="headerlink" title="bean的循环依赖"></a>bean的循环依赖</h3><p>当有两个及以上的bean互相调用时会发生循环依赖，最后形成闭环。Spring中使用了<strong>三级缓存</strong>机制来避免循环依赖问题。<strong>一级缓存</strong>中存放已经具有<strong>完整生命周期，初始化完成的bean</strong>。<strong>二级缓存</strong>中存放<strong>早期</strong>的bean。而<strong>三级缓存</strong>中存放的是<strong>对象工厂的引用</strong>，是用来创建bean的。Spring在创建bean时，首先会从一级缓存中查找，如果没有找到，则会从二级缓存中查找，如果还是没有找到，则会从三级缓存中查找，如果还是没有找到，则会使用对象工厂创建bean。<br>但是如果<strong>构造方法</strong>中出现了循环依赖问题，Spring的三级缓存对其是没有作用的。这时候就需要我们在方法中加上@Lazy懒加载注解，这样Spring在创建bean时，会延迟加载bean，直到第一次使用时才会创建。</p><h2 id="关于Spring-mvc的执行流程"><a href="#关于Spring-mvc的执行流程" class="headerlink" title="关于Spring mvc的执行流程"></a>关于Spring mvc的执行流程</h2><p>1.用户发出请求到前端控制器DispatcherServlet。<br>2.DispatcherServlet收到请求后，调用HandlerMapping查找Handler。<br>3.HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给DispatcherServlet。<br>4.DispatcherServlet调用HandlerAdapter适配器，对处理器进行执行。<br>5.HandlerAdapter根据处理器类型调用相应的处理器适配器。<br>6.在方法中添加@RequestMapping注解，可以指定请求的URL和请求方法。<br>7.通过HttpMessageConverter来返回结果转换为JSON并响应。</p><h2 id="关于Springboot的自动装配原理"><a href="#关于Springboot的自动装配原理" class="headerlink" title="关于Springboot的自动装配原理"></a>关于Springboot的自动装配原理</h2><p>Spring Boot 通过@EnableAutoConfiguration开启自动装配，通过 SpringFactoriesLoader 最终加载META-INF/spring.factories中的自动配置类实现自动装配，自动配置类其实就是通过@Conditional按需加载的配置类，想要其生效必须引入spring-boot-starter-xxx包实现起步依赖.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于HashMap的基本原理</title>
      <link href="/2024/07/15/2024-7-15-%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2024/07/15/2024-7-15-%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="简述HashMap的基本原理"><a href="#简述HashMap的基本原理" class="headerlink" title="简述HashMap的基本原理"></a>简述HashMap的基本原理</h2><p>HashMap是基于哈希表实现的，由数组+链表\红黑树组成。在添加数据时先计算key的哈希值，若key的哈希值和某个值的哈希值相同，则比对key和值的区别，若相同则进行替换，若不同则存入链表或红黑树中。具体在下面的put方法实现中。<br>在JDK1.7版本中，HashMap仅采用数组加链表的形式进行存储，后来在JDK1.8中引入了红黑树，在链表长度&gt;8且数组长度&gt;64时，链表会自动转换为红黑树进行存储，若红黑树的大小小于6时会退化成链表。</p><h2 id="简述HashMap的put过程"><a href="#简述HashMap的put过程" class="headerlink" title="简述HashMap的put过程"></a>简述HashMap的put过程</h2><p>Hash在添加数据时首先会进行判断，判断数组是否为空，若为空则初始化一个长度为16的数组并进行添加。若不为空则根据key的哈希值进行索引，若哈希值为空则直接添加，并判断size+1是否大于临界值，若大于临界值则需要进行扩容。若key的哈希值不为空则有两种情况，一种是有两个一模一样的key插入进来，还有一种就是虽然哈希值相同但是key不相同，因为哈希值是有限的。这时候就要判断key是否相同。若相同则直接进行替换，以最后的key为主。若不相同则要把kv存入数组下的链表或红黑树中。这时候我们要先进行判断数组下面连着的是不是红黑树。如果是红黑树则要判断红黑树中的key是否相同，若相同则直接替换，若不同则红黑树添加。如果不是红黑树我们则要先遍历链表，检验key是否已经在链表中存在，若存在则进行覆盖，若不存在则在链表的末尾添加该kv。添加后我们还需要对链表的长度进行判断，若链表的长度大于8且数组的长度大于64，则链表需要转换为红黑树。</p><h2 id="简述HashMap的扩容过程"><a href="#简述HashMap的扩容过程" class="headerlink" title="简述HashMap的扩容过程"></a>简述HashMap的扩容过程</h2><p>首先我们要判断HashMap的旧容量（oldCap）是否大于0.若不大于0则证明此HashMap是刚刚创建的，需要对其进行初始化，我们设置容量为16的数组，设置扩容阈值为16*0.75=12，当容量大于12时会进行自动扩容。若旧容量大于0则证明已经初始化完成。那么我们就新建一个容量为原数组2倍的新数组，并将原数组的数据复制到新数组中。若数组中的next为空，则证明数组下面没有链表或红黑树，可以直接添加到新数组。若不为空我们就要判断下面的数据结构是否为红黑树。若是红黑树我们直接红黑树添加。若不是我们则先要遍历链表，并判断原标的哈希值和新表的哈希值是否相同。若相同则把该数组下面的所有值放置原位，若不相同则把需要移动的数组的所有值安置在原始位置+增加的数组大小的位置上。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap是HashMap的线程安全版本，所以在数据结构上和HashMap基本相同。在Java1.7版本中使用的是分段的数组+链表，在1.8版本中则跟HashMap1.8一样使用率数组+链表/红黑树。<br>1.7版本中ConcurrentHashMap采用了分段锁，底层使用的是ReentrantLock.在put的时候要先计算key的哈希值，定位到segment，如果是空就先初始化segment.若不为空则使用ReetrantLock加锁，如果获取锁失败就自旋获取，如果自旋超过一定次数就阻塞获取，保证能获取到锁。之后的流程和HashMap1.7版本相同。<br>1.8版本中ConcurrentHashMap采用了CAS+Synchronized来保证线程安全。相对于segment来说锁粒度更细，性能更好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于ArrayList和LinkedList以及其他单列集合</title>
      <link href="/2024/07/13/2024-7-13-%E5%85%B3%E4%BA%8EArrayList%E5%92%8CLinkedList%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88/"/>
      <url>/2024/07/13/2024-7-13-%E5%85%B3%E4%BA%8EArrayList%E5%92%8CLinkedList%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>单列：（基于Collectrion）<br>    List(<strong>ArrayList</strong>,<strong>LinkedList</strong>,Vector)<br>    Set(HashSet,TreeSet)<br>双列：(基于Map)<br>Map(<strong>HashMap</strong>,<strong>ConcurrentHashMap</strong>,HashTable,TreeMap)</p><h2 id="ArrayList基本概述与扩容机制"><a href="#ArrayList基本概述与扩容机制" class="headerlink" title="ArrayList基本概述与扩容机制"></a>ArrayList基本概述与扩容机制</h2><p>ArrayList是由动态数组实现的，初始容量为0，在第一次添加数据时会出发ArrayList扩容机制扩容到10。当添加的数量超过了ArrayList的容量时，ArrayList会自动扩容为原来的1.5倍。关于ArrayList的扩容机制，ArrayList会调用ensureCapacityInternal方法先判断容量是否足够，如果不够就创建一个原来长度1.5倍的新数组，然后把原数组复制到新数组中，并且添加要添加的元素。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>ArrayList是基于动态数组实现的，而LinkedList是基于双向链表实现的。在查找数据时，ArrayList可以使用下标进行查询，时间复杂度是O(1),而LinkedList需要遍历链表，时间复杂度是O(n)。但是他们两个都不是线程安全的。如需保证线程安全，可以在方法内使用，或使用synchronized关键字对两个集合进行修饰。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单描述一下JVM中的垃圾回收</title>
      <link href="/2024/07/06/2024-7-6-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2024/07/06/2024-7-6-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="判断对象什么时候回收"><a href="#判断对象什么时候回收" class="headerlink" title="判断对象什么时候回收"></a>判断对象什么时候回收</h2><p>一般有两种方法，分别是引用计数法和可达性分析法。<br><strong>引用计数法</strong> 一个对象被引用一次，就在当前对象上递增一次引用次数，如果对象引用次数为0则可回收。但是如果两个对象循环引用，会导致该方法失效。<br><strong>可达性分析法</strong> 基于“GC Roots”的对象图，从GC Roots开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连时，则该对象可回收。现在的虚拟机都是采用该方法进行对象回收的判断。</p><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>一般有三种方法，分别是引用计数法和可达性分析法。<br><strong>标记清除算法</strong> 在内存中将需要存活的对象做出标记，那么没被标记的对象就是可以回收的对象。效率较高，但是会留下大量的内存碎片不能好好利用。<br><strong>标记整理算法</strong> 为了利用清楚算法残留的内存碎片，将存活对象移动到内存的一端，然后清理掉端边界以外的内存。这样留下了大块的内存，但是需要移动对象，效率较低。<br><strong>标记复制算法</strong> 将内存分成两等块，每次只使用其中一块，当一块内存用完后，将存活对象复制到另一块内存中，然后将第一块内存清空。可以有哦小利用内存，但是每次只使用内存的一半，对内存的使用率低。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>java1.8版本后的堆中有新生代和老年代，内存占用比例大概是1:2。在新生代的内存中有分为三个区域，eden区和两个幸存者区，内存比例大概是8:1:1.<br>在新生代中，新创建的对象会分配到eden区，当eden区内存不足的时候，会使用可达性分析法判断存活对象，并把该对象放入其中一个幸存者区中。当eden区又接收了很多新对象内存不足时，会使用可行性分析法判断存活对象，并把edne的存活对象和第一个幸存区的存活对象一起放到第二个幸存者区中。当处于幸存者区的对象经历最多15次回收后还存活，会把该对象存入老年代。<br><strong>MinorGC</strong> 一般发生在新生代的垃圾回收，stop the world（会暂停所有线程，进行标记整理算法）的时间会很快，效率高<br><strong>MixedGC</strong> 一般发生在新生代和老年代部分区域的垃圾回收，以G1收集器。<br><strong>FullGC</strong>  一般是新生代和老年代的完整垃圾回收，stw时间很长。</p><h2 id="垃圾回收器盘点"><a href="#垃圾回收器盘点" class="headerlink" title="垃圾回收器盘点"></a>垃圾回收器盘点</h2><p><strong>串行垃圾回收器</strong> 一般由 <strong>Serial</strong> 、<strong>Serial Old</strong> 组成，<strong>Serial</strong>作用于新生代，采用复制算法，<strong>Serial Old</strong>作用于老年代，采用标记整理算法。在垃圾回收时只有一个线程可以工作，其他线程都需stw。<br><strong>并行垃圾回收器</strong> 一般由 <strong>Parallel New</strong> 、<strong>Parallel Old</strong> 组成，<strong>Parallel New</strong>作用于新生代，采用复制算法，<strong>Parallel Old</strong>作用于老年代，采用标记整理算法。在垃圾回收时多个线程可以进行回收工作，其他线程都需stw。<br><strong>并发垃圾回收器（CMS）</strong> 使用标记清除算法，并发对老年代垃圾进行回收。首先回收的线程会进行初始标记，这时其他线程会进入stw状态，之后进入并发标记，并发标记时剩下线程可以正常运行。并发标记过后所有线程都需进行重新标记，最后回收线程进行清理，其他线程正常运行。<br><strong>G1垃圾回收器</strong> 应用于新生代和老年代，在JDK9后默认使用G1.划分了多个区域，分为eden,survivor,old,humongous四个区域，其中humongous专为大对象准备。采用复制算法，分为新生代回收，并发标记，混合收集三个阶段。如并发失败会出发Full GC.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单描述一下JVM中的类加载器和类加载机制</title>
      <link href="/2024/07/05/2024-7-5-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/07/05/2024-7-5-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>首先，因为JVM只能运行二进制文件，为了能让JVM看懂文件都写了什么，我们要使用类加载器把.java文件编译成jvm能看懂的字节码文件并加载到JVM中。<br>类加载器主要由BootStrap（启动类加载器）、Extension（扩展类加载器）、AppClassLoader（应用类加载器）三个部分组成。<br>JVM在类需要加载的时候会直接委派给父类加载器也就是启动类加载器，如果加载不了再往下传，直到应用类加载器。这么做保证了两个好处。<br>一是通过双亲委派机制可以避免类被重复加载，确保唯一性和效率，二是保证类库的api不会被修改，确保安全性。</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类从被加载到JVM到卸出内存一共分为七个阶段<br>首先是类的加载阶段，JVM通过类加载器加载类，把.class文件加载到内存中。<br>其次是连接阶段，JVM通过验证，准备，解析三个步骤来链接类，验证是为了确保类文件能够被JVM正确执行，准备是为类分配内存，一般是分配默认值，解析是把符号引用转换成直接引用。<br>然后是类的初始化阶段，一般这个阶段会把类赋予我们期望的值。但是如果我们新建的类是使用final修饰的基本类型，则赋值会直接在准备阶段完成。<br>最后是类的使用和销毁阶段，在使用类时我们会调用类的方法，当类不再被使用时，JVM会回收内存。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单描述一下JVM中运行时内存的组成</title>
      <link href="/2024/07/04/2024-7-4-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90/"/>
      <url>/2024/07/04/2024-7-4-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>在JVM中的运行数据区中，主要有程序计数器，虚拟机栈，本地方法栈，堆，方法区，运行时常量池等。下面简单介绍一下这几个区的作用。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器主要用于记录正在执行的字节码指令的地址。它是线程私有的，每个线程都有一个，所以不存在线程并发问题。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>是每个线程运行时所需要的内存，由栈帧组成，对应每次调用方法所占用的内存，每个线程只能有一个活动栈帧。<br>同时虚拟机栈中不涉及垃圾回收机制，栈帧弹出后内存就会释放。<br>若方法内局部变量没有逃离方法都作用范围，则是线程安全的。若局部变量逃离作用范围或引用了对象，则会出现线程安全问题。<br>同时，栈帧过多或栈帧过大会导致内存溢出。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要用于存放类信息、常量、静态变量、即时编译器编译后的代码等。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>主要用于保存对象和数组等，是所有线程共享的内存区域。划分为年轻代和老年代。在年轻代主要划分为三部分，由eden区，存放新创建的对象和两个survior区组成。老年代一般存放生命周期较长的对象。在java1.7版本中，堆内存还存有永久代，在1.8中永久代被划分到了本地内存元空间中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于MySQL中的事务</title>
      <link href="/2024/06/29/2024-6-29-%E5%85%B3%E4%BA%8EMySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/06/29/2024-6-29-%E5%85%B3%E4%BA%8EMySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h2><p>原子性：事务要么都发生要么都不发生<br>一致性：事务在运行前和运行后数据应保持一致<br>隔离性：类似于线程，事务在运行期间对其他事务不可见<br>持久性：事务对数据库的操作是永久的，不可逆转</p><h2 id="并发事务以及隔离手段"><a href="#并发事务以及隔离手段" class="headerlink" title="并发事务以及隔离手段"></a>并发事务以及隔离手段</h2><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><p>在对数据库进行操作时可能会发生并发问题。<br>在<strong>读读</strong>操作时一般不涉及并发问题<br>在<strong>读写</strong>操作时一般会发生三个问题，<strong>脏读，幻读，不可重复读</strong><br>其中脏读是指事务A进行了修改但没提交，事务B读到了修改，但同时事务A回滚了，所以事务A修改的数据就没了。但是事务B中读到了事务A回滚前的没用的数据，就是读到了脏数据。<br>幻读和不可重复读差不多，只不过幻读是事务B在读取数据时事务A同时新增了一条数据，同时事务B插入数据时发现该数据已存在。而不可重复读是事务B在读取数据时事务A修改了数据，事务B两次读到的结果不一致。所以幻读是新增，不可重复读是修改。<br>在<strong>写写</strong>操作时会发生<strong>数据丢失问题</strong></p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p><strong>RU(Read Uncommitted)</strong> 读未提交，不提供任何锁保护读取的数据，隔离级别最低，脏读、幻读、不可重复读都会发生。<br><strong>RC(Read Committed)</strong>   读已提交，事务修改数据时，事务还没提交的话别的事务无法读取数据，可以隔离脏读。<br><strong>RR(Repeatable reads)</strong> 可重复读，sql第一次读到数据时加悲观锁，让其他事务不可修改，解决了脏读和不可重复读问题。<br><strong>Serializable</strong>         串行化，最高的隔离级别，通过强制事务排序，使得并发操作变串行化，避免了脏读、幻读、不可重复读。</p><h2 id="undo-log和redo-log的区别"><a href="#undo-log和redo-log的区别" class="headerlink" title="undo log和redo log的区别"></a>undo log和redo log的区别</h2><p>redo log:记录事务提交时数据页的物理变化，当服务器宕机时可以用redo log的数据进行回复，实现事务的<strong>持久性</strong>。<br>undo log:记录数据被修改的信息。当事务进行<strong>insert</strong>时，undo log会写入一条<strong>delete</strong>数据，同理在<strong>delete</strong>时会写入一条<strong>insert</strong>数据，当<strong>update</strong>时会写入一条update相反的数据。这样做时为了在事务进行回滚时，可以将数据恢复到修改前的状态。实现了事务的<strong>一致性</strong>和<strong>原子性</strong>。</p><h2 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h2><p>多版本并发控制，维护数据的多个版本，使读写操作没有冲突。<br>mvcc的实现主要依赖数据库中的<strong>隐式字段</strong>，<strong>undo log日志</strong>和<strong>readView</strong>.<br>隐式字段： 1.DB_TRX_ID 记录每一次操作的事务id,自增<br>          2.DB_ROLL_PTR 指向undo日志记录的指针，记录了上一个版本的信息。通过该指针可以访问上一个版本的数据。<br>undo log: 1.回滚日志，存储老版本数据。<br>          2.版本链，记录所有版本的指针，通过版本链可以访问历史版本的数据。<br>readView: 根据readView匹配规则和事务id判断当前事务是否可以读取某个版本的数据。<br>          不同隔离级别快照读不一样 RC中每一次执行快照读都生成readView,RR中快照读时只第一次生成readView.</p><h3 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h3><p>当前读：每次读取都是当前最新数据，在读时不允许写，在写时不允许读。一般用于修改数据，读取时会加入排他锁来保证读写不共用。<br>快照读：读取的是快照数据，当前数据在被修改时可以进行读取，读写不冲突。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于MySQL中的索引</title>
      <link href="/2024/06/28/2024-6-28-%E5%85%B3%E4%BA%8EMySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
      <url>/2024/06/28/2024-6-28-%E5%85%B3%E4%BA%8EMySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h2><p>索引是帮助MySQL高效获取数据的数据结构，降低数据库的IO成本。索引有两种实现方式，分别是B+树和Hash索引。虽然Hash索引相对来说查询效率更快，但是Innodb的索引默认是用B+树实现的。因为B+树支持范围索引。用B+树不用B树的原因主要是B+树因为采用了非叶子节点只存储指针，叶子节点存储数据，且叶子节点直接用双向链表链接，这使得B+树的高度更低，一般只有三层，磁盘读写代价更低。</p><h3 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h3><p>聚集索引：数据和索引放在一起，B+树的叶子节点保存了整行数据，有且只有一个<br>非聚集索引：数据和索引分开存储，B+树的叶子节点保存了主键值，可以有多个</p><h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h3><p>通过非聚集索引找到对应的主键值，到聚集索引中查找整行数据。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>在使用索引查询时需要返回的列可以在该索引中直接找到，不需要进行回表查询。</p><h2 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h2><p>1.数据量大且查询频繁的表<br>2.使用where,order by,group by等字段的表<br>3.选择区分度高的列作为索引，使用唯一索引<br>4.字段过长时可以针对字段特点创建索引<br>5.尽量使用联合索引，覆盖索引<br>6.控制索引数量，不是越多越好<br>7.若索引列不能存储null,则创建表时使用not null约束</p><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p>1.违反最左原则<br>2.在join时左表或右表有一个没使用索引<br>3.在sql语句中进行隐性数据转换<br>4.在索引上做运算操作<br>5.在索引上引用函数（在MySQL8中新增了函数索引解决此问题）<br>6.like语句中%在开头</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于@Autowired和@Resource的区别</title>
      <link href="/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8E@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8E@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>首先说一下共同点，两者都是用来注入依赖的注解，且都可以声明在字段和setter方法上。<br>下面说一下区别</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p><strong>@Autowired</strong> 是由Spring框架提供的，默认通过<strong>byType</strong>注入。<br>若有一个UserService和两个实现类UserServiceImpl1和UserServiceImpl2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br></pre></td></tr></table></figure><br>通过@Autowired注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><br>但显而易见，直接注入会报错。<strong>@Autowired</strong>默认通过<strong>byType</strong>注入，但是UserService有两个实现类，我们无法确定是哪一个，所以我们通过<strong>byNames</strong>注入。<br>但是<strong>byNames</strong>所需的变量名也无法匹配ioc容器中有的id,所以会报错。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.改变变量名</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userServiceImpl1;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.使用@Qualifier注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p><strong>@Resource</strong> 是由J2EE提供的，默认通过<strong>byName</strong>注入。<br>若有一个UserService和两个实现类UserServiceImpl1和UserServiceImpl2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br></pre></td></tr></table></figure><br>通过@Resource注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><br><strong>@Resource</strong>默认通过<strong>byName</strong>注入，但是UserService这个变量名无法和IOC容器中的任何一个id进行匹配，我们无法确定是哪一个，所以我们通过<strong>byType</strong>注入。<br>但是使用<strong>byType</strong>后发现UserService中的实现类有两个，无法确定用哪个，所以报错。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.指定name</span></span><br><span class="line"><span class="meta">@Autowired(name = &quot;UserService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.指定type</span></span><br><span class="line"><span class="meta">@Autowired(type = &quot;UserService.class&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.同时指定name和type</span></span><br><span class="line"><span class="meta">@Autowired(name = &quot;UserService&quot; ,type = &quot;UserService.class&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring中的byName和byType的区别</title>
      <link href="/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8ESpring%E4%B8%AD%E7%9A%84byName%E5%92%8CbyType%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8ESpring%E4%B8%AD%E7%9A%84byName%E5%92%8CbyType%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>下面是一段示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userServiceImpl&quot;</span> class=<span class="string">&quot;cn.com.bochy.service.impl.UserServiceImpl&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;cn.com.bochy.dao.impl.UserDaoImpl&quot;</span>&gt; &lt;/bean&gt;</span><br></pre></td></tr></table></figure><br>在上面这段代码中，byName是通过Bean的id或name来自动装配依赖，而byType则是通过Bean的类型来自动装配依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当**@AutoWired**=&quot;byName&quot;时 是通过id = &quot;userDao&quot; 来查找Bean中的userDao对象。</span><br><span class="line">当**@AutoWired**=&quot;byType&quot;时 是通过class = &quot;cn.com.bochy.dao.impl.UserDaoImpl&quot; 来查找UserDaoImpl下的所有对象。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于String,StringBuffer和StringBuilder的区别</title>
      <link href="/2024/05/21/2024-5-21-%E5%85%B3%E4%BA%8EString,StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/05/21/2024-5-21-%E5%85%B3%E4%BA%8EString,StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>String</strong> 内部由final修饰，所以String不可变。线程安全性高。然而因为他不可变，所以每一次字符串进行修改的时候都需要重新创建对象并分布内存，性能低。</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><strong>StringBuffer</strong> 是可变类，同时方法中添加了synchroized关键字，保证线程安全。字符串进行修改时无需新建对象，加了同步锁，效率比String高。</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p><strong>StringBuilder</strong> 是可变类，线程不安全，字符串进行修改时无需新建对象，效率最高。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于@RequestBody,@RequestParam和@PathVariable的区别</title>
      <link href="/2024/04/22/2024-4-22-%E5%85%B3%E4%BA%8E@RequestBody,@RequestParam%E5%92%8C@PathVariable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/04/22/2024-4-22-%E5%85%B3%E4%BA%8E@RequestBody,@RequestParam%E5%92%8C@PathVariable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p><strong>@RequestBody</strong> 主要用于接收前端传递给后端的<strong>json</strong>字符串中的数据<br>通常处理POST或PUT请求，请求体中包含<strong>对象</strong>数据<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加学生</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">addStudent</span><span class="params">(<span class="meta">@RequestBody</span> StudentDTO studentDTO)</span>&#123;</span><br><span class="line">       studentService.addStudent(studentDTO);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p><strong>@RequestParam</strong> 主要用于查询字符串或表单数据中获取<strong>单个</strong>参数值<br>一般后面接单个变量，而不是像@RequestBody一样接整个对象<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id删除学生</span></span><br><span class="line">   <span class="meta">@DeleteMapping()</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">deleteStudent</span><span class="params">(<span class="meta">@RequestParam</span> Long id)</span>&#123;</span><br><span class="line">       studentService.deleteStudent(id);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>使用@RequestParam修饰后面的变量时，Postman中的测试接口需要占位符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Http://localhost:8080/admin/student/?id=2</span><br></pre></td></tr></table></figure></p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><strong>@PathVariable</strong> 用来接收请求路径中占位符的值<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id删除学生</span></span><br><span class="line">   <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">deleteStudent</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">       studentService.deleteStudent(id);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>用@PathVariable修饰后面的变量时，Postman中的测试接口则不需要占位符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Http://localhost:8080/admin/student/2</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于一些常用的命令</title>
      <link href="/2024/03/31/2024-3-31-%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/03/31/2024-3-31-%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h2><p>关于Redis的启动，首先我们应该<strong>进入redis的安装目录下，在地址栏输入cmd并回车</strong><br>我的Redis安装在了如下位置：d:/Redis-5.0.14.1</p><h3 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h3><p>先使用该命令对Redis进行初次部署<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><br>使用此命令将Redis添加到服务中，可以保证关闭cmd窗口仍然运行，重启电脑Redis开机自启。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-install redis.windows-service.conf --loglevel verbose</span><br></pre></td></tr></table></figure><br>在此状态下，我们导航到redis的安装目录<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开启服务</span><br><span class="line">redis-server --service-<span class="built_in">start</span></span><br><span class="line">停止服务</span><br><span class="line">redis-server --service-stop</span><br><span class="line">卸载Redis</span><br><span class="line">redis-server --service-uninstall</span><br></pre></td></tr></table></figure><br><strong>此改动我们称之为高效</strong></p><h2 id="Cpolar篇"><a href="#Cpolar篇" class="headerlink" title="Cpolar篇"></a>Cpolar篇</h2><p>关于Cpolar的启动，首先我们应该<strong>进入Cpolar的安装目录下，在地址栏输入cmd并回车,</strong><br>我的Cpolar安装在了如下位置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\cpolar</span><br></pre></td></tr></table></figure><br>然后我们会进入到Cpolar界面，直接输入,()中为你自己的token,具体去coplar网站上找<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar.exe autotoken (token)</span><br></pre></td></tr></table></figure><br>要在端口8080上启动HTTP隧道，请运行以下命令：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar.exe http <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><h2 id="Hexo篇"><a href="#Hexo篇" class="headerlink" title="Hexo篇"></a>Hexo篇</h2><p>本地推流命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl;hexo s</span><br></pre></td></tr></table></figure><br>github推流命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean;hexo generate;hexo deploy</span><br></pre></td></tr></table></figure></p><h2 id="Vue篇"><a href="#Vue篇" class="headerlink" title="Vue篇"></a>Vue篇</h2><p>用vite创建vue工程<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite</span><br></pre></td></tr></table></figure></p><h2 id="关于查看电脑已连接的WIFI的密码"><a href="#关于查看电脑已连接的WIFI的密码" class="headerlink" title="关于查看电脑已连接的WIFI的密码"></a>关于查看电脑已连接的WIFI的密码</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Netsh wlan show profile name=”Wi-F名称” key=clear</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown渲染测试</title>
      <link href="/2024/03/29/2024-3-29-markdown%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/03/29/2024-3-29-markdown%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。"><a href="#由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。" class="headerlink" title="由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。"></a>由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。</h1><h1 id="标题测试"><a href="#标题测试" class="headerlink" title="标题测试"></a>标题测试</h1><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题</span></span><br><span class="line"><span class="section">##### 这是五级标题</span></span><br></pre></td></tr></table></figure><h1 id="字体测试"><a href="#字体测试" class="headerlink" title="字体测试"></a>字体测试</h1><p><em>斜体文本</em></p><p>_斜体文本_</p><p><strong>粗体文本</strong></p><p><strong>粗体文本</strong></p><p><strong><em>粗斜体文本</em></strong></p><p><strong>_粗斜体文本_</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure><h1 id="公式渲染测试"><a href="#公式渲染测试" class="headerlink" title="公式渲染测试"></a>公式渲染测试</h1><p>这是行内公式：$\alpha = sin \sigma + \beta$ 行内公式结束。</p><p>公式段：</p><script type="math/tex; mode=display">\alpha = sin \sigma + \beta</script><p>Latex多种格式渲染测试</p><script type="math/tex; mode=display"> a+b=\frac{a}{b}  \\ \left(a+b=\frac{a}{b} \right) \\ a^b+a_b=a ^ {数学} \\ \cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}</script><script type="math/tex; mode=display"> \\ \sum_{i=1}^{n} x_{i}=\int_{0}^{1}f(x)\, {\rm d}x  \\ \sum\limits_{i=1}^{n} x_{i}=\int_{0}^{1}f(x)\, {\rm d}x \oint</script><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"> a+b=<span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125; </span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\left</span>(a+b=<span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125; <span class="keyword">\right</span>)</span><br><span class="line"> <span class="keyword">\\</span> a<span class="built_in">^</span>b+a<span class="built_in">_</span>b=a <span class="built_in">^</span> &#123;数学&#125;</span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\cal</span>&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br><span class="line"> <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125; x<span class="built_in">_</span>&#123;i&#125;=<span class="keyword">\int</span><span class="built_in">_</span>&#123;0&#125;<span class="built_in">^</span>&#123;1&#125;f(x)<span class="keyword">\,</span> &#123;<span class="keyword">\rm</span> d&#125;x </span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="built_in">_</span>&#123;&#123;1<span class="keyword">\le</span> i<span class="keyword">\le</span> n&#125;<span class="keyword">\atop</span> &#123;1<span class="keyword">\le</span> j<span class="keyword">\le</span> n&#125;&#125;a<span class="built_in">_</span>&#123;ij&#125;</span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125; x<span class="built_in">_</span>&#123;i&#125;=<span class="keyword">\int</span><span class="built_in">_</span>&#123;0&#125;<span class="built_in">^</span>&#123;1&#125;f(x)<span class="keyword">\,</span> &#123;<span class="keyword">\rm</span> d&#125;x <span class="keyword">\oint</span> </span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><h1 id="表格测试"><a href="#表格测试" class="headerlink" title="表格测试"></a>表格测试</h1><div class="table-container"><table><thead><tr><th style="text-align:left">这是表头左对齐1</th><th style="text-align:right">这是表头右对齐2</th><th style="text-align:center">这是表头中心对齐3</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:right">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">5</td><td style="text-align:center">6</td></tr></tbody></table></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|这是表头左对齐1|这是表头右对齐2|这是表头中心对齐3|</span><br><span class="line">|:-|-:|:-:|</span><br><span class="line">|1|2|3|</span><br><span class="line">|4|5|6|</span><br></pre></td></tr></table></figure><h1 id="列表测试"><a href="#列表测试" class="headerlink" title="列表测试"></a>列表测试</h1><p>无序：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>嵌套：</p><ol><li><p>第一项</p><ul><li>第一项1</li><li>第一项2</li></ul></li><li><p>第二项</p><ul><li>第二项1</li><li>第二项2</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    无序：</span></span><br><span class="line"><span class="code">- 第一项</span></span><br><span class="line"><span class="code">- 第二项</span></span><br><span class="line"><span class="code">- 第三项</span></span><br><span class="line"><span class="code">* 第一项</span></span><br><span class="line"><span class="code">* 第二项</span></span><br><span class="line"><span class="code">* 第三项</span></span><br><span class="line"><span class="code">+ 第一项</span></span><br><span class="line"><span class="code">+ 第二项</span></span><br><span class="line"><span class="code">+ 第三项</span></span><br><span class="line"><span class="code">有序：</span></span><br><span class="line"><span class="code">1. 第一项</span></span><br><span class="line"><span class="code">2. 第二项</span></span><br><span class="line"><span class="code">3. 第三项</span></span><br><span class="line"><span class="code">嵌套：</span></span><br><span class="line"><span class="code">1. 第一项</span></span><br><span class="line"><span class="code">    + 第一项1</span></span><br><span class="line"><span class="code">    + 第一项2</span></span><br><span class="line"><span class="code">2. 第二项</span></span><br><span class="line"><span class="code">    + 第二项1</span></span><br><span class="line"><span class="code">    + 第二项2</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

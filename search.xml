<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于HashMap的基本原理</title>
      <link href="/2024/07/15/2024-7-15-%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2024/07/15/2024-7-15-%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="简述HashMap的基本原理"><a href="#简述HashMap的基本原理" class="headerlink" title="简述HashMap的基本原理"></a>简述HashMap的基本原理</h2><p>HashMap是基于哈希表实现的，由数组+链表\红黑树组成。在添加数据时先计算key的哈希值，若key的哈希值和某个值的哈希值相同，则比对key和值的区别，若相同则进行替换，若不同则存入链表或红黑树中。具体在下面的put方法实现中。<br>在JDK1.7版本中，HashMap仅采用数组加链表的形式进行存储，后来在JDK1.8中引入了红黑树，在链表长度&gt;8且数组长度&gt;64时，链表会自动转换为红黑树进行存储，反之则会从红黑树退化回链表</p><h2 id="简述HashMap的put过程"><a href="#简述HashMap的put过程" class="headerlink" title="简述HashMap的put过程"></a>简述HashMap的put过程</h2><p>Hash在添加数据时首先会进行判断，判断数组是否为空，若为空则初始化一个长度为16的数组并进行添加。若不为空则根据key的哈希值进行索引，若哈希值为空则直接添加，并判断size+1是否大于临界值，若大于临界值则需要进行扩容。若key的哈希值不为空则有两种情况，一种是有两个一模一样的key插入进来，还有一种就是虽然哈希值相同但是key不相同，因为哈希值是有限的。这时候就要判断key是否相同。若相同则直接进行替换，以最后的key为主。若不相同则要把kv存入数组下的链表或红黑树中。这时候我们要先进行判断数组下面连着的是不是红黑树。如果是红黑树则直接在红黑树中进行添加。如果不是红黑树我们则要先遍历链表，检验key是否已经在链表中存在，若存在则进行覆盖，若不存在则在链表的末尾添加该kv。添加后我们还需要对链表的长度进行判断，若链表的长度大于8且数组的长度大于64，则链表需要转换为红黑树。</p><h2 id="简述HashMap的扩容过程"><a href="#简述HashMap的扩容过程" class="headerlink" title="简述HashMap的扩容过程"></a>简述HashMap的扩容过程</h2><p>首先我们要判断HashMap的旧容量（oldCap）是否大于0.若不大于0则证明此HashMap是刚刚创建的，需要对其进行初始化，我们设置容量为16的数组，设置扩容阈值为16*0.75=12，当容量大于12时会进行自动扩容。若旧容量大于0则证明已经初始化完成。那么我们就新建一个容量为原数组2倍的新数组，并将原数组的数据复制到新数组中。若数组中的next为空，则证明数组下面没有链表或红黑树，可以直接添加到新数组。若不为空我们就要判断下面的数据结构是否为红黑树。若是红黑树我们直接红黑树添加。若不是我们则先要遍历链表，并判断原标的哈希值和新表的哈希值是否相同。若相同则把该数组下面的所有值放置原位，若不相同则把需要移动的数组的所有值安置在原始位置+增加的数组大小的位置上。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于ArrayList和LinkedList以及其他单列集合</title>
      <link href="/2024/07/13/2024-7-13-%E5%85%B3%E4%BA%8EArrayList%E5%92%8CLinkedList%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%20copy/"/>
      <url>/2024/07/13/2024-7-13-%E5%85%B3%E4%BA%8EArrayList%E5%92%8CLinkedList%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>单列：（基于Collectrion）<br>    List(<strong>ArrayList</strong>,<strong>LinkedList</strong>,Vector)<br>    Set(HashSet,TreeSet)<br>双列：(基于Map)<br>Map(<strong>HashMap</strong>,<strong>ConcurrentHashMap</strong>,HashTable,TreeMap)</p><h2 id="ArrayList基本概述与扩容机制"><a href="#ArrayList基本概述与扩容机制" class="headerlink" title="ArrayList基本概述与扩容机制"></a>ArrayList基本概述与扩容机制</h2><p>ArrayList是由动态数组实现的，初始容量为0，在第一次添加数据时会出发ArrayList扩容机制扩容到10。当添加的数量超过了ArrayList的容量时，ArrayList会自动扩容为原来的1.5倍。关于ArrayList的扩容机制，ArrayList会调用ensureCapacityInternal方法先判断容量是否足够，如果不够就创建一个原来长度1.5倍的新数组，然后把原数组复制到新数组中，并且添加要添加的元素。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>ArrayList是基于动态数组实现的，而LinkedList是基于双向链表实现的。在查找数据时，ArrayList可以使用下标进行查询，时间复杂度是O(1),而LinkedList需要遍历链表，时间复杂度是O(n)。但是他们两个都不是线程安全的。如需保证线程安全，可以在方法内使用，或使用synchronized关键字对两个集合进行修饰。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单描述一下JVM中的垃圾回收</title>
      <link href="/2024/07/06/2024-7-6-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%20copy/"/>
      <url>/2024/07/06/2024-7-6-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="判断对象什么时候回收"><a href="#判断对象什么时候回收" class="headerlink" title="判断对象什么时候回收"></a>判断对象什么时候回收</h2><p>一般有两种方法，分别是引用计数法和可达性分析法。<br><strong>引用计数法</strong> 一个对象被引用一次，就在当前对象上递增一次引用次数，如果对象引用次数为0则可回收。但是如果两个对象循环引用，会导致该方法失效。<br><strong>可达性分析法</strong> 基于“GC Roots”的对象图，从GC Roots开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连时，则该对象可回收。现在的虚拟机都是采用该方法进行对象回收的判断。</p><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>一般有三种方法，分别是引用计数法和可达性分析法。<br><strong>标记清除算法</strong> 在内存中将需要存活的对象做出标记，那么没被标记的对象就是可以回收的对象。效率较高，但是会留下大量的内存碎片不能好好利用。<br><strong>标记整理算法</strong> 为了利用清楚算法残留的内存碎片，将存活对象移动到内存的一端，然后清理掉端边界以外的内存。这样留下了大块的内存，但是需要移动对象，效率较低。<br><strong>标记复制算法</strong> 将内存分成两等块，每次只使用其中一块，当一块内存用完后，将存活对象复制到另一块内存中，然后将第一块内存清空。可以有哦小利用内存，但是每次只使用内存的一半，对内存的使用率低。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>java1.8版本后的堆中有新生代和老年代，内存占用比例大概是1:2。在新生代的内存中有分为三个区域，eden区和两个幸存者区，内存比例大概是8:1:1.<br>在新生代中，新创建的对象会分配到eden区，当eden区内存不足的时候，会使用可达性分析法判断存活对象，并把该对象放入其中一个幸存者区中。当eden区又接收了很多新对象内存不足时，会使用可行性分析法判断存活对象，并把edne的存活对象和第一个幸存区的存活对象一起放到第二个幸存者区中。当处于幸存者区的对象经历最多15次回收后还存活，会把该对象存入老年代。<br><strong>MinorGC</strong> 一般发生在新生代的垃圾回收，stop the world（会暂停所有线程，进行标记整理算法）的时间会很快，效率高<br><strong>MixedGC</strong> 一般发生在新生代和老年代部分区域的垃圾回收，以G1收集器。<br><strong>FullGC</strong>  一般是新生代和老年代的完整垃圾回收，stw时间很长。</p><h2 id="垃圾回收器盘点"><a href="#垃圾回收器盘点" class="headerlink" title="垃圾回收器盘点"></a>垃圾回收器盘点</h2><p><strong>串行垃圾回收器</strong> 一般由 <strong>Serial</strong> 、<strong>Serial Old</strong> 组成，<strong>Serial</strong>作用于新生代，采用复制算法，<strong>Serial Old</strong>作用于老年代，采用标记整理算法。在垃圾回收时只有一个线程可以工作，其他线程都需stw。<br><strong>并行垃圾回收器</strong> 一般由 <strong>Parallel New</strong> 、<strong>Parallel Old</strong> 组成，<strong>Parallel New</strong>作用于新生代，采用复制算法，<strong>Parallel Old</strong>作用于老年代，采用标记整理算法。在垃圾回收时多个线程可以进行回收工作，其他线程都需stw。<br><strong>并发垃圾回收器（CMS）</strong> 使用标记清除算法，并发对老年代垃圾进行回收。首先回收的线程会进行初始标记，这时其他线程会进入stw状态，之后进入并发标记，并发标记时剩下线程可以正常运行。并发标记过后所有线程都需进行重新标记，最后回收线程进行清理，其他线程正常运行。<br><strong>G1垃圾回收器</strong> 应用于新生代和老年代，在JDK9后默认使用G1.划分了多个区域，分为eden,survivor,old,humongous四个区域，其中humongous专为大对象准备。采用复制算法，分为新生代回收，并发标记，混合收集三个阶段。如并发失败会出发Full GC.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单描述一下JVM中的类加载器和类加载机制</title>
      <link href="/2024/07/05/2024-7-5-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%20copy/"/>
      <url>/2024/07/05/2024-7-5-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>首先，因为JVM只能运行二进制文件，为了能让JVM看懂文件都写了什么，我们要使用类加载器把字节码文件，也就是.class文件加载到JVM中。<br>类加载器主要由BootStrap（启动类加载器）、Extension（扩展类加载器）、AppClassLoader（应用类加载器）三个部分组成。<br>JVM在类需要加载的时候会直接委派给父类加载器也就是启动类加载器，如果加载不了再往下传，直到应用类加载器。这么做保证了两个好处。<br>一是通过双亲委派机制可以避免类被重复加载，确保唯一性和效率，二是保证类库的api不会被修改，确保安全性。</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类从被加载到JVM到卸出内存一共分为七个阶段<br>首先是类的加载阶段，JVM通过类加载器加载类，把.class文件加载到内存中。<br>其次是连接阶段，JVM通过验证，准备，解析三个步骤来链接类，验证是为了确保类文件能够被JVM正确执行，准备是为类分配内存，一般是分配默认值，解析是把符号引用转换成直接引用。<br>然后是类的初始化阶段，一般这个阶段会把类赋予我们期望的值。<br>最后是类的使用和销毁阶段，在使用类时我们会调用类的方法，当类不再被使用时，JVM会回收内存。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单描述一下JVM中运行时内存的组成</title>
      <link href="/2024/07/04/2024-7-4-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90%20copy/"/>
      <url>/2024/07/04/2024-7-4-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90%20copy/</url>
      
        <content type="html"><![CDATA[<p>在JVM中的运行数据区中，主要有程序计数器，虚拟机栈，本地方法栈，堆，方法区，运行时常量池等。下面简单介绍一下这几个区的作用。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器主要用于记录正在执行的字节码指令的地址。它是线程私有的，每个线程都有一个，所以不存在线程并发问题。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>是每个线程运行时所需要的内存，由栈帧组成，对应每次调用方法所占用的内存，每个线程只能有一个活动栈帧。<br>同时虚拟机栈中不涉及垃圾回收机制，栈帧弹出后内存就会释放。<br>若方法内局部变量没有逃离方法都作用范围，则是线程安全的。若局部变量逃离作用范围或引用了对象，则会出现线程安全问题。<br>同时，栈帧过多或栈帧过大会导致内存溢出。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要用于存放类信息、常量、静态变量、即时编译器编译后的代码等。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>主要用于保存对象和数组等，是所有线程共享的内存区域。划分为年轻代和老年代。在年轻代主要划分为三部分，由eden区，存放新创建的对象和两个survior区组成。老年代一般存放生命周期较长的对象。在java1.7版本中，堆内存还存有永久代，在1.8中永久代被划分到了本地内存元空间中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于@Autowired和@Resource的区别</title>
      <link href="/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8E@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8E@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>首先说一下共同点，两者都是用来注入依赖的注解，且都可以声明在字段和setter方法上。<br>下面说一下区别</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p><strong>@Autowired</strong> 是由Spring框架提供的，默认通过<strong>byType</strong>注入。<br>若有一个UserService和两个实现类UserServiceImpl1和UserServiceImpl2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br></pre></td></tr></table></figure><br>通过@Autowired注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><br>但显而易见，直接注入会报错。<strong>@Autowired</strong>默认通过<strong>byType</strong>注入，但是UserService有两个实现类，我们无法确定是哪一个，所以我们通过<strong>byNames</strong>注入。<br>但是<strong>byNames</strong>所需的变量名也无法匹配ioc容器中有的id,所以会报错。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.改变变量名</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userServiceImpl1;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.使用@Qualifier注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p><strong>@Resource</strong> 是由J2EE提供的，默认通过<strong>byName</strong>注入。<br>若有一个UserService和两个实现类UserServiceImpl1和UserServiceImpl2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br></pre></td></tr></table></figure><br>通过@Resource注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><br><strong>@Resource</strong>默认通过<strong>byName</strong>注入，但是UserService这个变量名无法和IOC容器中的任何一个id进行匹配，我们无法确定是哪一个，所以我们通过<strong>byType</strong>注入。<br>但是使用<strong>byType</strong>后发现UserService中的实现类有两个，无法确定用哪个，所以报错。</p><h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.指定name</span></span><br><span class="line"><span class="meta">@Autowired(name = &quot;UserService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.指定type</span></span><br><span class="line"><span class="meta">@Autowired(type = &quot;UserService.class&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.同时指定name和type</span></span><br><span class="line"><span class="meta">@Autowired(name = &quot;UserService&quot; ,type = &quot;UserService.class&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring中的byName和byType的区别</title>
      <link href="/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8ESpring%E4%B8%AD%E7%9A%84byName%E5%92%8CbyType%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/"/>
      <url>/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8ESpring%E4%B8%AD%E7%9A%84byName%E5%92%8CbyType%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/</url>
      
        <content type="html"><![CDATA[<p>下面是一段示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userServiceImpl&quot;</span> class=<span class="string">&quot;cn.com.bochy.service.impl.UserServiceImpl&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;cn.com.bochy.dao.impl.UserDaoImpl&quot;</span>&gt; &lt;/bean&gt;</span><br></pre></td></tr></table></figure><br>在上面这段代码中，byName是通过Bean的id或name来自动装配依赖，而byType则是通过Bean的类型来自动装配依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当**@AutoWired**=&quot;byName&quot;时 是通过id = &quot;userDao&quot; 来查找Bean中的userDao对象。</span><br><span class="line">当**@AutoWired**=&quot;byType&quot;时 是通过class = &quot;cn.com.bochy.dao.impl.UserDaoImpl&quot; 来查找UserDaoImpl下的所有对象。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于String,StringBuffer和StringBuilder的区别</title>
      <link href="/2024/05/21/2024-5-21-%E5%85%B3%E4%BA%8EString,StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/"/>
      <url>/2024/05/21/2024-5-21-%E5%85%B3%E4%BA%8EString,StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>String</strong> 内部由final修饰，所以String不可变。线程安全性高。然而因为他不可变，所以每一次字符串进行修改的时候都需要重新创建对象并分布内存，性能低。</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><strong>StringBuffer</strong> 是可变类，同时方法中添加了synchroized关键字，保证线程安全。字符串进行修改时无需新建对象，加了同步锁，效率比String高。</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p><strong>StringBuilder</strong> 是可变类，线程不安全，字符串进行修改时无需新建对象，效率最高。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于@RequestBody,@RequestParam和@PathVariable的区别</title>
      <link href="/2024/04/22/2024-4-22-%E5%85%B3%E4%BA%8E@RequestBody,@RequestParam%E5%92%8C@PathVariable%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/"/>
      <url>/2024/04/22/2024-4-22-%E5%85%B3%E4%BA%8E@RequestBody,@RequestParam%E5%92%8C@PathVariable%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p><strong>@RequestBody</strong> 主要用于接收前端传递给后端的<strong>json</strong>字符串中的数据<br>通常处理POST或PUT请求，请求体中包含<strong>对象</strong>数据<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加学生</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">addStudent</span><span class="params">(<span class="meta">@RequestBody</span> StudentDTO studentDTO)</span>&#123;</span><br><span class="line">       studentService.addStudent(studentDTO);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p><strong>@RequestParam</strong> 主要用于查询字符串或表单数据中获取<strong>单个</strong>参数值<br>一般后面接单个变量，而不是像@RequestBody一样接整个对象<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id删除学生</span></span><br><span class="line">   <span class="meta">@DeleteMapping()</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">deleteStudent</span><span class="params">(<span class="meta">@RequestParam</span> Long id)</span>&#123;</span><br><span class="line">       studentService.deleteStudent(id);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>使用@RequestParam修饰后面的变量时，Postman中的测试接口需要占位符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Http://localhost:8080/admin/student/?id=2</span><br></pre></td></tr></table></figure></p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><strong>@PathVariable</strong> 用来接收请求路径中占位符的值<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id删除学生</span></span><br><span class="line">   <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">deleteStudent</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">       studentService.deleteStudent(id);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>用@PathVariable修饰后面的变量时，Postman中的测试接口则不需要占位符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Http://localhost:8080/admin/student/2</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于一些常用的命令</title>
      <link href="/2024/03/31/2024-3-31-%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%20copy/"/>
      <url>/2024/03/31/2024-3-31-%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h2><p>关于Redis的启动，首先我们应该<strong>进入redis的安装目录下，在地址栏输入cmd并回车</strong><br>然后我们会进入到redis界面，直接输入<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><br>如果结果像下图一样，则证明redis启动成功<br><img src="https://img2.imgtp.com/2024/03/31/j93P1rCP.png" alt="redis"><br>如果报错请依次输入下面的指令后，再输入上述命令。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cl.exe</span><br><span class="line">shutdown</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></p><h2 id="Cpolar篇"><a href="#Cpolar篇" class="headerlink" title="Cpolar篇"></a>Cpolar篇</h2><p>关于Cpolar的启动，首先我们应该<strong>进入Cpolar的安装目录下，在地址栏输入cmd并回车,</strong><br>我的Cpolar安装在了如下位置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\cpolar</span><br></pre></td></tr></table></figure><br>然后我们会进入到Cpolar界面，直接输入,()中为你自己的token,具体去coplar网站上找<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar.exe autotoken (token)</span><br></pre></td></tr></table></figure><br>要在端口8080上启动HTTP隧道，请运行以下命令：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar.exe http <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><h2 id="Hexo篇"><a href="#Hexo篇" class="headerlink" title="Hexo篇"></a>Hexo篇</h2><p>本地推流命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl;hexo s</span><br></pre></td></tr></table></figure><br>github推流命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean;hexo generate;hexo deploy</span><br></pre></td></tr></table></figure></p><h2 id="Vue篇"><a href="#Vue篇" class="headerlink" title="Vue篇"></a>Vue篇</h2><p>用vite创建vue工程<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown渲染测试</title>
      <link href="/2024/03/29/2024-3-29-markdown%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/03/29/2024-3-29-markdown%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。"><a href="#由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。" class="headerlink" title="由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。"></a>由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。</h1><h1 id="标题测试"><a href="#标题测试" class="headerlink" title="标题测试"></a>标题测试</h1><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题</span></span><br><span class="line"><span class="section">##### 这是五级标题</span></span><br></pre></td></tr></table></figure><h1 id="字体测试"><a href="#字体测试" class="headerlink" title="字体测试"></a>字体测试</h1><p><em>斜体文本</em></p><p>_斜体文本_</p><p><strong>粗体文本</strong></p><p><strong>粗体文本</strong></p><p><strong><em>粗斜体文本</em></strong></p><p><strong>_粗斜体文本_</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure><h1 id="公式渲染测试"><a href="#公式渲染测试" class="headerlink" title="公式渲染测试"></a>公式渲染测试</h1><p>这是行内公式：$\alpha = sin \sigma + \beta$ 行内公式结束。</p><p>公式段：</p><script type="math/tex; mode=display">\alpha = sin \sigma + \beta</script><p>Latex多种格式渲染测试</p><script type="math/tex; mode=display"> a+b=\frac{a}{b}  \\ \left(a+b=\frac{a}{b} \right) \\ a^b+a_b=a ^ {数学} \\ \cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}</script><script type="math/tex; mode=display"> \\ \sum_{i=1}^{n} x_{i}=\int_{0}^{1}f(x)\, {\rm d}x  \\ \sum\limits_{i=1}^{n} x_{i}=\int_{0}^{1}f(x)\, {\rm d}x \oint</script><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"> a+b=<span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125; </span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\left</span>(a+b=<span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125; <span class="keyword">\right</span>)</span><br><span class="line"> <span class="keyword">\\</span> a<span class="built_in">^</span>b+a<span class="built_in">_</span>b=a <span class="built_in">^</span> &#123;数学&#125;</span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\cal</span>&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br><span class="line"> <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125; x<span class="built_in">_</span>&#123;i&#125;=<span class="keyword">\int</span><span class="built_in">_</span>&#123;0&#125;<span class="built_in">^</span>&#123;1&#125;f(x)<span class="keyword">\,</span> &#123;<span class="keyword">\rm</span> d&#125;x </span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="built_in">_</span>&#123;&#123;1<span class="keyword">\le</span> i<span class="keyword">\le</span> n&#125;<span class="keyword">\atop</span> &#123;1<span class="keyword">\le</span> j<span class="keyword">\le</span> n&#125;&#125;a<span class="built_in">_</span>&#123;ij&#125;</span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125; x<span class="built_in">_</span>&#123;i&#125;=<span class="keyword">\int</span><span class="built_in">_</span>&#123;0&#125;<span class="built_in">^</span>&#123;1&#125;f(x)<span class="keyword">\,</span> &#123;<span class="keyword">\rm</span> d&#125;x <span class="keyword">\oint</span> </span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><h1 id="表格测试"><a href="#表格测试" class="headerlink" title="表格测试"></a>表格测试</h1><div class="table-container"><table><thead><tr><th style="text-align:left">这是表头左对齐1</th><th style="text-align:right">这是表头右对齐2</th><th style="text-align:center">这是表头中心对齐3</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:right">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">5</td><td style="text-align:center">6</td></tr></tbody></table></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|这是表头左对齐1|这是表头右对齐2|这是表头中心对齐3|</span><br><span class="line">|:-|-:|:-:|</span><br><span class="line">|1|2|3|</span><br><span class="line">|4|5|6|</span><br></pre></td></tr></table></figure><h1 id="列表测试"><a href="#列表测试" class="headerlink" title="列表测试"></a>列表测试</h1><p>无序：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>嵌套：</p><ol><li><p>第一项</p><ul><li>第一项1</li><li>第一项2</li></ul></li><li><p>第二项</p><ul><li>第二项1</li><li>第二项2</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    无序：</span></span><br><span class="line"><span class="code">- 第一项</span></span><br><span class="line"><span class="code">- 第二项</span></span><br><span class="line"><span class="code">- 第三项</span></span><br><span class="line"><span class="code">* 第一项</span></span><br><span class="line"><span class="code">* 第二项</span></span><br><span class="line"><span class="code">* 第三项</span></span><br><span class="line"><span class="code">+ 第一项</span></span><br><span class="line"><span class="code">+ 第二项</span></span><br><span class="line"><span class="code">+ 第三项</span></span><br><span class="line"><span class="code">有序：</span></span><br><span class="line"><span class="code">1. 第一项</span></span><br><span class="line"><span class="code">2. 第二项</span></span><br><span class="line"><span class="code">3. 第三项</span></span><br><span class="line"><span class="code">嵌套：</span></span><br><span class="line"><span class="code">1. 第一项</span></span><br><span class="line"><span class="code">    + 第一项1</span></span><br><span class="line"><span class="code">    + 第一项2</span></span><br><span class="line"><span class="code">2. 第二项</span></span><br><span class="line"><span class="code">    + 第二项1</span></span><br><span class="line"><span class="code">    + 第二项2</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

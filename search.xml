<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简单描述一下JVM中运行时内存的组成</title>
      <link href="/2024/07/04/2024-7-4-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90%20copy/"/>
      <url>/2024/07/04/2024-7-4-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90%20copy/</url>
      
        <content type="html"><![CDATA[<p>在JVM中的运行数据区中，主要有程序计数器，虚拟机栈，本地方法栈，堆，方法区，运行时常量池等。下面简单介绍一下这几个区的作用。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器主要用于记录正在执行的字节码指令的地址。它是线程私有的，每个线程都有一个，所以不存在线程并发问题。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>是每个线程运行时所需要的内存，由栈帧组成，对应每次调用方法所占用的内存，每个线程只能有一个活动栈帧。<br>同时虚拟机栈中不涉及垃圾回收机制，栈帧弹出后内存就会释放。<br>若方法内局部变量没有逃离方法都作用范围，则是线程安全的。若局部变量逃离作用范围或引用了对象，则会出现线程安全问题。<br>同时，栈帧过多或栈帧过大会导致内存溢出。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要用于存放类信息、常量、静态变量、即时编译器编译后的代码等。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>主要用于保存对象和数组等，是所有线程共享的内存区域。划分为年轻代和老年代。在年轻代主要划分为三部分，由eden区，存放新创建的对象和两个survior区组成。老年代一般存放生命周期较长的对象。在java1.7版本中，堆内存还存有永久代，在1.8中永久代被划分到了本地内存元空间中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单描述一下JVM中的类加载器和类加载机制</title>
      <link href="/2024/07/04/2024-7-5-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/07/04/2024-7-5-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BJVM%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>首先，因为JVM只能运行二进制文件，为了能让JVM看懂文件都写了什么，我们要使用类加载器把字节码文件，也就是.class文件加载到JVM中。<br>类加载器主要由BootStrap（启动类加载器）、Extension（扩展类加载器）、AppClassLoader（应用类加载器）三个部分组成。<br>JVM在类需要加载的时候会直接委派给父类加载器也就是启动类加载器，如果加载不了再往下传，直到应用类加载器。这么做保证了两个好处。<br>一是通过双亲委派机制可以避免类被重复加载，确保唯一性和效率，二是保证类库的api不会被修改，确保安全性。</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类从被加载到JVM到卸出内存一共分为七个阶段<br>首先是类的加载阶段，JVM通过类加载器加载类，把.class文件加载到内存中。<br>其次是连接阶段，JVM通过验证，准备，解析三个步骤来链接类，验证是为了确保类文件能够被JVM正确执行，准备是为类分配内存，一般是分配默认值，解析是把符号引用转换成直接引用。<br>然后是类的初始化阶段，一般这个阶段会把类赋予我们期望的值。<br>最后是类的使用和销毁阶段，在使用类时我们会调用类的方法，当类不再被使用时，JVM会回收内存。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于@Autowired和@Resource的区别</title>
      <link href="/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8E@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8E@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>首先说一下共同点，两者都是用来注入依赖的注解，且都可以声明在字段和setter方法上。<br>下面说一下区别</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p><strong>@Autowired</strong> 是由Spring框架提供的，默认通过<strong>byType</strong>注入。<br>若有一个UserService和两个实现类UserServiceImpl1和UserServiceImpl2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br></pre></td></tr></table></figure><br>通过@Autowired注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><br>但显而易见，直接注入会报错。<strong>@Autowired</strong>默认通过<strong>byType</strong>注入，但是UserService有两个实现类，我们无法确定是哪一个，所以我们通过<strong>byNames</strong>注入。<br>但是<strong>byNames</strong>所需的变量名也无法匹配ioc容器中有的id,所以会报错。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.改变变量名</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userServiceImpl1;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.使用@Qualifier注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p><strong>@Resource</strong> 是由J2EE提供的，默认通过<strong>byName</strong>注入。<br>若有一个UserService和两个实现类UserServiceImpl1和UserServiceImpl2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>;</span><br></pre></td></tr></table></figure><br>通过@Resource注入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><br><strong>@Resource</strong>默认通过<strong>byName</strong>注入，但是UserService这个变量名无法和IOC容器中的任何一个id进行匹配，我们无法确定是哪一个，所以我们通过<strong>byType</strong>注入。<br>但是使用<strong>byType</strong>后发现UserService中的实现类有两个，无法确定用哪个，所以报错。</p><h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.指定name</span></span><br><span class="line"><span class="meta">@Autowired(name = &quot;UserService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.指定type</span></span><br><span class="line"><span class="meta">@Autowired(type = &quot;UserService.class&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.同时指定name和type</span></span><br><span class="line"><span class="meta">@Autowired(name = &quot;UserService&quot; ,type = &quot;UserService.class&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring中的byName和byType的区别</title>
      <link href="/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8ESpring%E4%B8%AD%E7%9A%84byName%E5%92%8CbyType%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/"/>
      <url>/2024/06/25/2024-6-25-%E5%85%B3%E4%BA%8ESpring%E4%B8%AD%E7%9A%84byName%E5%92%8CbyType%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/</url>
      
        <content type="html"><![CDATA[<p>下面是一段示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;userServiceImpl&quot;</span> class=<span class="string">&quot;cn.com.bochy.service.impl.UserServiceImpl&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>&gt;</span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;cn.com.bochy.dao.impl.UserDaoImpl&quot;</span>&gt; &lt;/bean&gt;</span><br></pre></td></tr></table></figure><br>在上面这段代码中，byName是通过Bean的id或name来自动装配依赖，而byType则是通过Bean的类型来自动装配依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当**@AutoWired**=&quot;byName&quot;时 是通过id = &quot;userDao&quot; 来查找Bean中的userDao对象。</span><br><span class="line">当**@AutoWired**=&quot;byType&quot;时 是通过class = &quot;cn.com.bochy.dao.impl.UserDaoImpl&quot; 来查找UserDaoImpl下的所有对象。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于String,StringBuffer和StringBuilder的区别</title>
      <link href="/2024/05/21/2024-5-21-%E5%85%B3%E4%BA%8EString,StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/"/>
      <url>/2024/05/21/2024-5-21-%E5%85%B3%E4%BA%8EString,StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>String</strong> 内部由final修饰，所以String不可变。线程安全性高。然而因为他不可变，所以每一次字符串进行修改的时候都需要重新创建对象并分布内存，性能低。</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><strong>StringBuffer</strong> 是可变类，同时方法中添加了synchroized关键字，保证线程安全。字符串进行修改时无需新建对象，加了同步锁，效率比String高。</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p><strong>StringBuilder</strong> 是可变类，线程不安全，字符串进行修改时无需新建对象，效率最高。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于@RequestBody,@RequestParam和@PathVariable的区别</title>
      <link href="/2024/04/22/2024-4-22-%E5%85%B3%E4%BA%8E@RequestBody,@RequestParam%E5%92%8C@PathVariable%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/"/>
      <url>/2024/04/22/2024-4-22-%E5%85%B3%E4%BA%8E@RequestBody,@RequestParam%E5%92%8C@PathVariable%E7%9A%84%E5%8C%BA%E5%88%AB%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p><strong>@RequestBody</strong> 主要用于接收前端传递给后端的<strong>json</strong>字符串中的数据<br>通常处理POST或PUT请求，请求体中包含<strong>对象</strong>数据<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加学生</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">addStudent</span><span class="params">(<span class="meta">@RequestBody</span> StudentDTO studentDTO)</span>&#123;</span><br><span class="line">       studentService.addStudent(studentDTO);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p><strong>@RequestParam</strong> 主要用于查询字符串或表单数据中获取<strong>单个</strong>参数值<br>一般后面接单个变量，而不是像@RequestBody一样接整个对象<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id删除学生</span></span><br><span class="line">   <span class="meta">@DeleteMapping()</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">deleteStudent</span><span class="params">(<span class="meta">@RequestParam</span> Long id)</span>&#123;</span><br><span class="line">       studentService.deleteStudent(id);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>使用@RequestParam修饰后面的变量时，Postman中的测试接口需要占位符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Http://localhost:8080/admin/student/?id=2</span><br></pre></td></tr></table></figure></p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><strong>@PathVariable</strong> 用来接收请求路径中占位符的值<br>示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id删除学生</span></span><br><span class="line">   <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">deleteStudent</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">       studentService.deleteStudent(id);</span><br><span class="line">       <span class="keyword">return</span> Result.success();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>用@PathVariable修饰后面的变量时，Postman中的测试接口则不需要占位符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Http://localhost:8080/admin/student/2</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于一些常用的命令</title>
      <link href="/2024/03/31/2024-3-31-%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%20copy/"/>
      <url>/2024/03/31/2024-3-31-%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%20copy/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h2><p>关于Redis的启动，首先我们应该<strong>进入redis的安装目录下，在地址栏输入cmd并回车</strong><br>然后我们会进入到redis界面，直接输入<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><br>如果结果像下图一样，则证明redis启动成功<br><img src="https://img2.imgtp.com/2024/03/31/j93P1rCP.png" alt="redis"><br>如果报错请依次输入下面的指令后，再输入上述命令。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cl.exe</span><br><span class="line">shutdown</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></p><h2 id="Cpolar篇"><a href="#Cpolar篇" class="headerlink" title="Cpolar篇"></a>Cpolar篇</h2><p>关于Cpolar的启动，首先我们应该<strong>进入Cpolar的安装目录下，在地址栏输入cmd并回车,</strong><br>我的Cpolar安装在了如下位置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\cpolar</span><br></pre></td></tr></table></figure><br>然后我们会进入到Cpolar界面，直接输入,()中为你自己的token,具体去coplar网站上找<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar.exe autotoken (token)</span><br></pre></td></tr></table></figure><br>要在端口8080上启动HTTP隧道，请运行以下命令：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpolar.exe http <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><h2 id="Hexo篇"><a href="#Hexo篇" class="headerlink" title="Hexo篇"></a>Hexo篇</h2><p>本地推流命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl;hexo s</span><br></pre></td></tr></table></figure><br>github推流命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean;hexo generate;hexo deploy</span><br></pre></td></tr></table></figure></p><h2 id="Vue篇"><a href="#Vue篇" class="headerlink" title="Vue篇"></a>Vue篇</h2><p>用vite创建vue工程<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown渲染测试</title>
      <link href="/2024/03/29/2024-3-29-markdown%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/03/29/2024-3-29-markdown%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。"><a href="#由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。" class="headerlink" title="由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。"></a>由于多次配置博客，无法实时观测各效果的实现状况。故写此测试文章，后续插件有更新后再次进行修改。更新后采用引用格式作为标记。</h1><h1 id="标题测试"><a href="#标题测试" class="headerlink" title="标题测试"></a>标题测试</h1><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题</span></span><br><span class="line"><span class="section">##### 这是五级标题</span></span><br></pre></td></tr></table></figure><h1 id="字体测试"><a href="#字体测试" class="headerlink" title="字体测试"></a>字体测试</h1><p><em>斜体文本</em></p><p>_斜体文本_</p><p><strong>粗体文本</strong></p><p><strong>粗体文本</strong></p><p><strong><em>粗斜体文本</em></strong></p><p><strong>_粗斜体文本_</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文本_</span>__</span></span><br></pre></td></tr></table></figure><h1 id="公式渲染测试"><a href="#公式渲染测试" class="headerlink" title="公式渲染测试"></a>公式渲染测试</h1><p>这是行内公式：$\alpha = sin \sigma + \beta$ 行内公式结束。</p><p>公式段：</p><script type="math/tex; mode=display">\alpha = sin \sigma + \beta</script><p>Latex多种格式渲染测试</p><script type="math/tex; mode=display"> a+b=\frac{a}{b}  \\ \left(a+b=\frac{a}{b} \right) \\ a^b+a_b=a ^ {数学} \\ \cal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}</script><script type="math/tex; mode=display"> \\ \sum_{i=1}^{n} x_{i}=\int_{0}^{1}f(x)\, {\rm d}x  \\ \sum\limits_{i=1}^{n} x_{i}=\int_{0}^{1}f(x)\, {\rm d}x \oint</script><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"> a+b=<span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125; </span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\left</span>(a+b=<span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125; <span class="keyword">\right</span>)</span><br><span class="line"> <span class="keyword">\\</span> a<span class="built_in">^</span>b+a<span class="built_in">_</span>b=a <span class="built_in">^</span> &#123;数学&#125;</span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\cal</span>&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125;</span><br><span class="line"> <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125; x<span class="built_in">_</span>&#123;i&#125;=<span class="keyword">\int</span><span class="built_in">_</span>&#123;0&#125;<span class="built_in">^</span>&#123;1&#125;f(x)<span class="keyword">\,</span> &#123;<span class="keyword">\rm</span> d&#125;x </span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="built_in">_</span>&#123;&#123;1<span class="keyword">\le</span> i<span class="keyword">\le</span> n&#125;<span class="keyword">\atop</span> &#123;1<span class="keyword">\le</span> j<span class="keyword">\le</span> n&#125;&#125;a<span class="built_in">_</span>&#123;ij&#125;</span><br><span class="line"> <span class="keyword">\\</span> <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125; x<span class="built_in">_</span>&#123;i&#125;=<span class="keyword">\int</span><span class="built_in">_</span>&#123;0&#125;<span class="built_in">^</span>&#123;1&#125;f(x)<span class="keyword">\,</span> &#123;<span class="keyword">\rm</span> d&#125;x <span class="keyword">\oint</span> </span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><h1 id="表格测试"><a href="#表格测试" class="headerlink" title="表格测试"></a>表格测试</h1><div class="table-container"><table><thead><tr><th style="text-align:left">这是表头左对齐1</th><th style="text-align:right">这是表头右对齐2</th><th style="text-align:center">这是表头中心对齐3</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:right">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">5</td><td style="text-align:center">6</td></tr></tbody></table></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|这是表头左对齐1|这是表头右对齐2|这是表头中心对齐3|</span><br><span class="line">|:-|-:|:-:|</span><br><span class="line">|1|2|3|</span><br><span class="line">|4|5|6|</span><br></pre></td></tr></table></figure><h1 id="列表测试"><a href="#列表测试" class="headerlink" title="列表测试"></a>列表测试</h1><p>无序：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p>有序：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>嵌套：</p><ol><li><p>第一项</p><ul><li>第一项1</li><li>第一项2</li></ul></li><li><p>第二项</p><ul><li>第二项1</li><li>第二项2</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    无序：</span></span><br><span class="line"><span class="code">- 第一项</span></span><br><span class="line"><span class="code">- 第二项</span></span><br><span class="line"><span class="code">- 第三项</span></span><br><span class="line"><span class="code">* 第一项</span></span><br><span class="line"><span class="code">* 第二项</span></span><br><span class="line"><span class="code">* 第三项</span></span><br><span class="line"><span class="code">+ 第一项</span></span><br><span class="line"><span class="code">+ 第二项</span></span><br><span class="line"><span class="code">+ 第三项</span></span><br><span class="line"><span class="code">有序：</span></span><br><span class="line"><span class="code">1. 第一项</span></span><br><span class="line"><span class="code">2. 第二项</span></span><br><span class="line"><span class="code">3. 第三项</span></span><br><span class="line"><span class="code">嵌套：</span></span><br><span class="line"><span class="code">1. 第一项</span></span><br><span class="line"><span class="code">    + 第一项1</span></span><br><span class="line"><span class="code">    + 第一项2</span></span><br><span class="line"><span class="code">2. 第二项</span></span><br><span class="line"><span class="code">    + 第二项1</span></span><br><span class="line"><span class="code">    + 第二项2</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
